<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YASK: yask::yk_solution Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kit: a software framework for creating HPC stencil code. Copyright 2014-2019 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yask</b></li><li class="navelem"><a class="el" href="classyask_1_1yk__solution.html">yk_solution</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyask_1_1yk__solution-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yask::yk_solution Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__yk.html">YASK Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stencil solution as defined by the generated code from the YASK stencil compiler.  
 <a href="classyask_1_1yk__solution.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="yk__solution__api_8hpp_source.html">yk_solution_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a913e7b208c46bbad2115784332bc303d"><td class="memItemLeft" align="right" valign="top"><a id="a913e7b208c46bbad2115784332bc303d"></a>
typedef std::function&lt; void(<a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a913e7b208c46bbad2115784332bc303d">hook_fn_t</a></td></tr>
<tr class="memdesc:a913e7b208c46bbad2115784332bc303d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Callback type with <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> parameter. <br /></td></tr>
<tr class="separator:a913e7b208c46bbad2115784332bc303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2a4d0fdf7e975885eb638a3e192cf3"><td class="memItemLeft" align="right" valign="top"><a id="a1c2a4d0fdf7e975885eb638a3e192cf3"></a>
typedef std::function&lt; void(<a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> &amp;soln, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> first_step_index, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> last_step_index)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a1c2a4d0fdf7e975885eb638a3e192cf3">hook_fn_2idx_t</a></td></tr>
<tr class="memdesc:a1c2a4d0fdf7e975885eb638a3e192cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Callback type with <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> and step-index parameters. <br /></td></tr>
<tr class="separator:a1c2a4d0fdf7e975885eb638a3e192cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaafc0aa636a3d306e29771d5440c4aa4"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#aaafc0aa636a3d306e29771d5440c4aa4">get_name</a> () const =0</td></tr>
<tr class="memdesc:aaafc0aa636a3d306e29771d5440c4aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the solution.  <a href="#aaafc0aa636a3d306e29771d5440c4aa4">More...</a><br /></td></tr>
<tr class="separator:aaafc0aa636a3d306e29771d5440c4aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25bbfab5dffc379bfb8c55ac64d6898"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ab25bbfab5dffc379bfb8c55ac64d6898">get_target</a> () const =0</td></tr>
<tr class="memdesc:ab25bbfab5dffc379bfb8c55ac64d6898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target ISA.  <a href="#ab25bbfab5dffc379bfb8c55ac64d6898">More...</a><br /></td></tr>
<tr class="separator:ab25bbfab5dffc379bfb8c55ac64d6898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2978fb8fd701fe35ae8a8b19e23e5544"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a2978fb8fd701fe35ae8a8b19e23e5544">is_offloaded</a> () const =0</td></tr>
<tr class="memdesc:a2978fb8fd701fe35ae8a8b19e23e5544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the stencil kernel will be offloaded to a device.  <a href="#a2978fb8fd701fe35ae8a8b19e23e5544">More...</a><br /></td></tr>
<tr class="separator:a2978fb8fd701fe35ae8a8b19e23e5544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e565487b7175447cc9f6489221eef4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4">get_element_bytes</a> () const =0</td></tr>
<tr class="memdesc:a50e565487b7175447cc9f6489221eef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the floating-point precision size.  <a href="#a50e565487b7175447cc9f6489221eef4">More...</a><br /></td></tr>
<tr class="separator:a50e565487b7175447cc9f6489221eef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7039e7151857e2652592a585c6d00931"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a7039e7151857e2652592a585c6d00931">get_step_dim_name</a> () const =0</td></tr>
<tr class="memdesc:a7039e7151857e2652592a585c6d00931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solution step dimension.  <a href="#a7039e7151857e2652592a585c6d00931">More...</a><br /></td></tr>
<tr class="separator:a7039e7151857e2652592a585c6d00931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a13017d8c3a599d00b99561405dd3c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a40a13017d8c3a599d00b99561405dd3c">get_num_domain_dims</a> () const =0</td></tr>
<tr class="memdesc:a40a13017d8c3a599d00b99561405dd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of domain dimensions used in this solution.  <a href="#a40a13017d8c3a599d00b99561405dd3c">More...</a><br /></td></tr>
<tr class="separator:a40a13017d8c3a599d00b99561405dd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665968c18b2f70467dbc7decaeeb1a1f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f">get_domain_dim_names</a> () const =0</td></tr>
<tr class="memdesc:a665968c18b2f70467dbc7decaeeb1a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the domain dimension names.  <a href="#a665968c18b2f70467dbc7decaeeb1a1f">More...</a><br /></td></tr>
<tr class="separator:a665968c18b2f70467dbc7decaeeb1a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af895e7366f7f224c4e6fc780b0dd7a2f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#af895e7366f7f224c4e6fc780b0dd7a2f">get_misc_dim_names</a> () const =0</td></tr>
<tr class="memdesc:af895e7366f7f224c4e6fc780b0dd7a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the miscellaneous dimension names.  <a href="#af895e7366f7f224c4e6fc780b0dd7a2f">More...</a><br /></td></tr>
<tr class="separator:af895e7366f7f224c4e6fc780b0dd7a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155d8f4a38da9da11488a18cca50bae8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8">set_rank_domain_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a155d8f4a38da9da11488a18cca50bae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that is in this rank.  <a href="#a155d8f4a38da9da11488a18cca50bae8">More...</a><br /></td></tr>
<tr class="separator:a155d8f4a38da9da11488a18cca50bae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ba31268cb0098b64e4503c8996300f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a56ba31268cb0098b64e4503c8996300f">get_rank_domain_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a56ba31268cb0098b64e4503c8996300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local-domain size in the specified dimension, i.e., the size in this rank.  <a href="#a56ba31268cb0098b64e4503c8996300f">More...</a><br /></td></tr>
<tr class="separator:a56ba31268cb0098b64e4503c8996300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9a22d8d2b760a05307e90147d18d8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a7f9a22d8d2b760a05307e90147d18d8c">set_overall_domain_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a7f9a22d8d2b760a05307e90147d18d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks.  <a href="#a7f9a22d8d2b760a05307e90147d18d8c">More...</a><br /></td></tr>
<tr class="separator:a7f9a22d8d2b760a05307e90147d18d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba39cb06c9f61d408695009667fe8cd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#aaba39cb06c9f61d408695009667fe8cd">get_overall_domain_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:aaba39cb06c9f61d408695009667fe8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks.  <a href="#aaba39cb06c9f61d408695009667fe8cd">More...</a><br /></td></tr>
<tr class="separator:aaba39cb06c9f61d408695009667fe8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3c7317bf1b397f332962d658f38839"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839">set_block_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:abd3c7317bf1b397f332962d658f38839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the block size in the given dimension.  <a href="#abd3c7317bf1b397f332962d658f38839">More...</a><br /></td></tr>
<tr class="separator:abd3c7317bf1b397f332962d658f38839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601aeebc023d430a311788c3ce73c190"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a601aeebc023d430a311788c3ce73c190">get_block_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a601aeebc023d430a311788c3ce73c190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block size.  <a href="#a601aeebc023d430a311788c3ce73c190">More...</a><br /></td></tr>
<tr class="separator:a601aeebc023d430a311788c3ce73c190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cd27d412b6fe013db58b167999a362"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac4cd27d412b6fe013db58b167999a362">set_num_ranks</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> num)=0</td></tr>
<tr class="memdesc:ac4cd27d412b6fe013db58b167999a362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of MPI ranks in the given dimension.  <a href="#ac4cd27d412b6fe013db58b167999a362">More...</a><br /></td></tr>
<tr class="separator:ac4cd27d412b6fe013db58b167999a362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4449fe8902881c9a61ad12fd20a5a866"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a4449fe8902881c9a61ad12fd20a5a866">get_num_ranks</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a4449fe8902881c9a61ad12fd20a5a866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of MPI ranks in the given dimension.  <a href="#a4449fe8902881c9a61ad12fd20a5a866">More...</a><br /></td></tr>
<tr class="separator:a4449fe8902881c9a61ad12fd20a5a866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eccaa1d228d7f3408e3c2b0881f279"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac0eccaa1d228d7f3408e3c2b0881f279">set_rank_index</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> num)=0</td></tr>
<tr class="memdesc:ac0eccaa1d228d7f3408e3c2b0881f279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rank index in the specified dimension.  <a href="#ac0eccaa1d228d7f3408e3c2b0881f279">More...</a><br /></td></tr>
<tr class="separator:ac0eccaa1d228d7f3408e3c2b0881f279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3268e5e7e2f0e45f951f1c38063bc59f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a3268e5e7e2f0e45f951f1c38063bc59f">get_rank_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a3268e5e7e2f0e45f951f1c38063bc59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank index in the specified dimension.  <a href="#a3268e5e7e2f0e45f951f1c38063bc59f">More...</a><br /></td></tr>
<tr class="separator:a3268e5e7e2f0e45f951f1c38063bc59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac111abbade055c4923cd0044360ec3b7"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac111abbade055c4923cd0044360ec3b7">apply_command_line_options</a> (const std::string &amp;args)=0</td></tr>
<tr class="memdesc:ac111abbade055c4923cd0044360ec3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set kernel options from a string.  <a href="#ac111abbade055c4923cd0044360ec3b7">More...</a><br /></td></tr>
<tr class="separator:ac111abbade055c4923cd0044360ec3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0947c4ad4ed06d8a7d5058daecd5dc7"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ad0947c4ad4ed06d8a7d5058daecd5dc7">apply_command_line_options</a> (int argc, char *argv[])=0</td></tr>
<tr class="memdesc:ad0947c4ad4ed06d8a7d5058daecd5dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set kernel options from standard C or C++ <code>argc</code> and <code>argv</code> parameters to <code>main()</code>.  <a href="#ad0947c4ad4ed06d8a7d5058daecd5dc7">More...</a><br /></td></tr>
<tr class="separator:ad0947c4ad4ed06d8a7d5058daecd5dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c128cbf16d4d4ab36c30654cd0e9818"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a6c128cbf16d4d4ab36c30654cd0e9818">apply_command_line_options</a> (const std::vector&lt; std::string &gt; &amp;args)=0</td></tr>
<tr class="memdesc:a6c128cbf16d4d4ab36c30654cd0e9818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set kernel options from a vector of strings.  <a href="#a6c128cbf16d4d4ab36c30654cd0e9818">More...</a><br /></td></tr>
<tr class="separator:a6c128cbf16d4d4ab36c30654cd0e9818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0947f98bcea19c6400bcdf95ddf585"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a9e0947f98bcea19c6400bcdf95ddf585">get_num_vars</a> () const =0</td></tr>
<tr class="memdesc:a9e0947f98bcea19c6400bcdf95ddf585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vars in the solution.  <a href="#a9e0947f98bcea19c6400bcdf95ddf585">More...</a><br /></td></tr>
<tr class="separator:a9e0947f98bcea19c6400bcdf95ddf585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068d8968ac1846a9ea5af7ca2defaf79"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a068d8968ac1846a9ea5af7ca2defaf79">get_var</a> (const std::string &amp;name)=0</td></tr>
<tr class="memdesc:a068d8968ac1846a9ea5af7ca2defaf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified var.  <a href="#a068d8968ac1846a9ea5af7ca2defaf79">More...</a><br /></td></tr>
<tr class="separator:a068d8968ac1846a9ea5af7ca2defaf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1cd86caa28951a816f8c7959351155"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a0d1cd86caa28951a816f8c7959351155">get_vars</a> ()=0</td></tr>
<tr class="memdesc:a0d1cd86caa28951a816f8c7959351155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vars.  <a href="#a0d1cd86caa28951a816f8c7959351155">More...</a><br /></td></tr>
<tr class="separator:a0d1cd86caa28951a816f8c7959351155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0edfde033c251e3f8d2d184a682d4cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb">prepare_solution</a> ()=0</td></tr>
<tr class="memdesc:aa0edfde033c251e3f8d2d184a682d4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the solution for stencil application.  <a href="#aa0edfde033c251e3f8d2d184a682d4cb">More...</a><br /></td></tr>
<tr class="separator:aa0edfde033c251e3f8d2d184a682d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bdef5ba9b0b0e37f9b7be2e2e457a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a03bdef5ba9b0b0e37f9b7be2e2e457a4">get_first_rank_domain_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a03bdef5ba9b0b0e37f9b7be2e2e457a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of the sub-domain in this rank in the specified dimension.  <a href="#a03bdef5ba9b0b0e37f9b7be2e2e457a4">More...</a><br /></td></tr>
<tr class="separator:a03bdef5ba9b0b0e37f9b7be2e2e457a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2ce95e150787bc8235e85298dcd01"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a58f2ce95e150787bc8235e85298dcd01">get_last_rank_domain_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a58f2ce95e150787bc8235e85298dcd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of the sub-domain in this rank the specified dimension.  <a href="#a58f2ce95e150787bc8235e85298dcd01">More...</a><br /></td></tr>
<tr class="separator:a58f2ce95e150787bc8235e85298dcd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cc5625fc524fe8eb8d3cedc66778aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa">run_solution</a> (<a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> first_step_index, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> last_step_index)=0</td></tr>
<tr class="memdesc:a14cc5625fc524fe8eb8d3cedc66778aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the stencil solution for the specified steps.  <a href="#a14cc5625fc524fe8eb8d3cedc66778aa">More...</a><br /></td></tr>
<tr class="separator:a14cc5625fc524fe8eb8d3cedc66778aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dc15b38732b30c820ffd7765292342"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a46dc15b38732b30c820ffd7765292342">run_solution</a> (<a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> step_index)=0</td></tr>
<tr class="memdesc:a46dc15b38732b30c820ffd7765292342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the stencil solution for the specified step.  <a href="#a46dc15b38732b30c820ffd7765292342">More...</a><br /></td></tr>
<tr class="separator:a46dc15b38732b30c820ffd7765292342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdea230253b47bd16c1a0c326a78df8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a2cdea230253b47bd16c1a0c326a78df8">copy_vars_to_device</a> () const =0</td></tr>
<tr class="memdesc:a2cdea230253b47bd16c1a0c326a78df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update data on the device.  <a href="#a2cdea230253b47bd16c1a0c326a78df8">More...</a><br /></td></tr>
<tr class="separator:a2cdea230253b47bd16c1a0c326a78df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105c993241498d9c2a98cbec353fc61a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a105c993241498d9c2a98cbec353fc61a">copy_vars_from_device</a> () const =0</td></tr>
<tr class="memdesc:a105c993241498d9c2a98cbec353fc61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update data on the host.  <a href="#a105c993241498d9c2a98cbec353fc61a">More...</a><br /></td></tr>
<tr class="separator:a105c993241498d9c2a98cbec353fc61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac6a33fe5d098d31a844f4eba654b19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#afac6a33fe5d098d31a844f4eba654b19">end_solution</a> ()=0</td></tr>
<tr class="memdesc:afac6a33fe5d098d31a844f4eba654b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish using a solution.  <a href="#afac6a33fe5d098d31a844f4eba654b19">More...</a><br /></td></tr>
<tr class="separator:afac6a33fe5d098d31a844f4eba654b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2755703f0d90aa4e3ef36093a1976f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#ga12d1d46aeb01bd7509a8dc3251657f75">yk_stats_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ab2755703f0d90aa4e3ef36093a1976f5">get_stats</a> ()=0</td></tr>
<tr class="memdesc:ab2755703f0d90aa4e3ef36093a1976f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get performance statistics associated with preceding calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a>.  <a href="#ab2755703f0d90aa4e3ef36093a1976f5">More...</a><br /></td></tr>
<tr class="separator:ab2755703f0d90aa4e3ef36093a1976f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7eea6bfc844adcc584c2ca5c1f2ba4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a0f7eea6bfc844adcc584c2ca5c1f2ba4">is_auto_tuner_enabled</a> () const =0</td></tr>
<tr class="memdesc:a0f7eea6bfc844adcc584c2ca5c1f2ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the auto-tuner is enabled on this rank.  <a href="#a0f7eea6bfc844adcc584c2ca5c1f2ba4">More...</a><br /></td></tr>
<tr class="separator:a0f7eea6bfc844adcc584c2ca5c1f2ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bd7e95ea13631954d92a638badfb2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d">set_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:ab3bd7e95ea13631954d92a638badfb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum amount of padding for all vars.  <a href="#ab3bd7e95ea13631954d92a638badfb2d">More...</a><br /></td></tr>
<tr class="separator:ab3bd7e95ea13631954d92a638badfb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193d7c6e708c1ece4d78b39800a7d5fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a193d7c6e708c1ece4d78b39800a7d5fa">get_min_pad_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a193d7c6e708c1ece4d78b39800a7d5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the minimum amount of padding for all vars.  <a href="#a193d7c6e708c1ece4d78b39800a7d5fa">More...</a><br /></td></tr>
<tr class="separator:a193d7c6e708c1ece4d78b39800a7d5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932fad2ede1aecef168189c0aa972b0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a932fad2ede1aecef168189c0aa972b0b">reset_auto_tuner</a> (bool enable, bool verbose=false)=0</td></tr>
<tr class="memdesc:a932fad2ede1aecef168189c0aa972b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Restart or disable the auto-tuner on this rank.  <a href="#a932fad2ede1aecef168189c0aa972b0b">More...</a><br /></td></tr>
<tr class="separator:a932fad2ede1aecef168189c0aa972b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e92afeb1d201ea0174fa04029ec0077"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a8e92afeb1d201ea0174fa04029ec0077">run_auto_tuner_now</a> (bool verbose=true)=0</td></tr>
<tr class="memdesc:a8e92afeb1d201ea0174fa04029ec0077"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Automatically tune selected settings immediately.  <a href="#a8e92afeb1d201ea0174fa04029ec0077">More...</a><br /></td></tr>
<tr class="separator:a8e92afeb1d201ea0174fa04029ec0077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076e1cc78d96e7cc77ec62d58e289131"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131">new_var</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:a076e1cc78d96e7cc77ec62d58e289131"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new var to the solution.  <a href="#a076e1cc78d96e7cc77ec62d58e289131">More...</a><br /></td></tr>
<tr class="separator:a076e1cc78d96e7cc77ec62d58e289131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2774f810be2d57a878884111cbd36e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ae2774f810be2d57a878884111cbd36e9">new_var</a> (const std::string &amp;name, const std::initializer_list&lt; std::string &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:ae2774f810be2d57a878884111cbd36e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new var to the solution.  <a href="#ae2774f810be2d57a878884111cbd36e9">More...</a><br /></td></tr>
<tr class="separator:ae2774f810be2d57a878884111cbd36e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c44ba3941aa5682e381c7c36dcf453"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453">new_fixed_size_var</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;dims, const std::vector&lt; <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> &gt; &amp;dim_sizes)=0</td></tr>
<tr class="memdesc:a70c44ba3941aa5682e381c7c36dcf453"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new var to the solution with a specified size.  <a href="#a70c44ba3941aa5682e381c7c36dcf453">More...</a><br /></td></tr>
<tr class="separator:a70c44ba3941aa5682e381c7c36dcf453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b682d609950a4d9b9d8fb497aad9971"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a0b682d609950a4d9b9d8fb497aad9971">new_fixed_size_var</a> (const std::string &amp;name, const std::initializer_list&lt; std::string &gt; &amp;dims, const std::initializer_list&lt; <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> &gt; &amp;dim_sizes)=0</td></tr>
<tr class="memdesc:a0b682d609950a4d9b9d8fb497aad9971"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new var to the solution with a specified size.  <a href="#a0b682d609950a4d9b9d8fb497aad9971">More...</a><br /></td></tr>
<tr class="separator:a0b682d609950a4d9b9d8fb497aad9971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bde8dfc73219cec84ad3033faabb90"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac8bde8dfc73219cec84ad3033faabb90">set_default_numa_preferred</a> (int numa_node)=0</td></tr>
<tr class="memdesc:ac8bde8dfc73219cec84ad3033faabb90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data.  <a href="#ac8bde8dfc73219cec84ad3033faabb90">More...</a><br /></td></tr>
<tr class="separator:ac8bde8dfc73219cec84ad3033faabb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c98a1d8b03d1009ef67b84b2f0bea0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a05c98a1d8b03d1009ef67b84b2f0bea0">get_default_numa_preferred</a> () const =0</td></tr>
<tr class="memdesc:a05c98a1d8b03d1009ef67b84b2f0bea0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data.  <a href="#a05c98a1d8b03d1009ef67b84b2f0bea0">More...</a><br /></td></tr>
<tr class="separator:a05c98a1d8b03d1009ef67b84b2f0bea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa3d7e75bfcde066f1ea8b2871ced4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#aeaa3d7e75bfcde066f1ea8b2871ced4b">call_before_prepare_solution</a> (<a class="el" href="classyask_1_1yk__solution.html#a913e7b208c46bbad2115784332bc303d">hook_fn_t</a> hook_fn)=0</td></tr>
<tr class="memdesc:aeaa3d7e75bfcde066f1ea8b2871ced4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Register a function to be called at the beginning of <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>.  <a href="#aeaa3d7e75bfcde066f1ea8b2871ced4b">More...</a><br /></td></tr>
<tr class="separator:aeaa3d7e75bfcde066f1ea8b2871ced4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfa2c38e2ecbac19a989cc771b68627"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a2cfa2c38e2ecbac19a989cc771b68627">call_after_prepare_solution</a> (<a class="el" href="classyask_1_1yk__solution.html#a913e7b208c46bbad2115784332bc303d">hook_fn_t</a> hook_fn)=0</td></tr>
<tr class="memdesc:a2cfa2c38e2ecbac19a989cc771b68627"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Register a hook function to be called at the end of <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>.  <a href="#a2cfa2c38e2ecbac19a989cc771b68627">More...</a><br /></td></tr>
<tr class="separator:a2cfa2c38e2ecbac19a989cc771b68627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2291f79959831dcc378443c8f1152fc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a2291f79959831dcc378443c8f1152fc9">call_before_run_solution</a> (<a class="el" href="classyask_1_1yk__solution.html#a1c2a4d0fdf7e975885eb638a3e192cf3">hook_fn_2idx_t</a> hook_fn)=0</td></tr>
<tr class="memdesc:a2291f79959831dcc378443c8f1152fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Register a hook function to be called at the beginning of <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">yk_solution::run_solution()</a>.  <a href="#a2291f79959831dcc378443c8f1152fc9">More...</a><br /></td></tr>
<tr class="separator:a2291f79959831dcc378443c8f1152fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527715f33d673b45c4a833caa4de9d9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a527715f33d673b45c4a833caa4de9d9e">call_after_run_solution</a> (<a class="el" href="classyask_1_1yk__solution.html#a1c2a4d0fdf7e975885eb638a3e192cf3">hook_fn_2idx_t</a> hook_fn)=0</td></tr>
<tr class="memdesc:a527715f33d673b45c4a833caa4de9d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Register a hook function to be called at the end of <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">yk_solution::run_solution()</a>.  <a href="#a527715f33d673b45c4a833caa4de9d9e">More...</a><br /></td></tr>
<tr class="separator:a527715f33d673b45c4a833caa4de9d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563794842445fcd96d77b463f674a60b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a563794842445fcd96d77b463f674a60b">fuse_vars</a> (<a class="el" href="group__yk.html#ga2debaa7135bb46dfc295ca623bee2876">yk_solution_ptr</a> source)=0</td></tr>
<tr class="memdesc:a563794842445fcd96d77b463f674a60b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Merge YASK variables with another solution.  <a href="#a563794842445fcd96d77b463f674a60b">More...</a><br /></td></tr>
<tr class="separator:a563794842445fcd96d77b463f674a60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b7c6f23e3190f3958fa1843fd0cba0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#af9b7c6f23e3190f3958fa1843fd0cba0">set_step_wrap</a> (bool do_wrap)=0</td></tr>
<tr class="memdesc:af9b7c6f23e3190f3958fa1843fd0cba0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set whether invalid step indices alias to valid ones.  <a href="#af9b7c6f23e3190f3958fa1843fd0cba0">More...</a><br /></td></tr>
<tr class="separator:af9b7c6f23e3190f3958fa1843fd0cba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cf6be2225ae2273b921b85dd8c7ac5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ad9cf6be2225ae2273b921b85dd8c7ac5">get_step_wrap</a> () const =0</td></tr>
<tr class="memdesc:ad9cf6be2225ae2273b921b85dd8c7ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get whether invalid step indices alias to valid ones.  <a href="#ad9cf6be2225ae2273b921b85dd8c7ac5">More...</a><br /></td></tr>
<tr class="separator:ad9cf6be2225ae2273b921b85dd8c7ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8ce77d85b54ebaf15ddf11009066c4"><td class="memItemLeft" align="right" valign="top"><a id="a7e8ce77d85b54ebaf15ddf11009066c4"></a>
virtual <a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a7e8ce77d85b54ebaf15ddf11009066c4">set_debug_output</a> (<a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> debug)=0</td></tr>
<tr class="memdesc:a7e8ce77d85b54ebaf15ddf11009066c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><b>[Deprecated]</b></em> Use <a class="el" href="classyask_1_1yk__env.html#aa5cf0e8d885f4d9ebde6539d5246cda1" title="Set object to receive debug output.">yk_env::set_debug_output()</a>. <br /></td></tr>
<tr class="separator:a7e8ce77d85b54ebaf15ddf11009066c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a510dff4e18c716baeec707affd0124"><td class="memItemLeft" align="right" valign="top"><a id="a4a510dff4e18c716baeec707affd0124"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a4a510dff4e18c716baeec707affd0124">get_num_grids</a> () const</td></tr>
<tr class="memdesc:a4a510dff4e18c716baeec707affd0124"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a9e0947f98bcea19c6400bcdf95ddf585" title="Get the number of vars in the solution.">get_num_vars()</a>. <br /></td></tr>
<tr class="separator:a4a510dff4e18c716baeec707affd0124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561517d815dd1004e1c39557554eee16"><td class="memItemLeft" align="right" valign="top"><a id="a561517d815dd1004e1c39557554eee16"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a561517d815dd1004e1c39557554eee16">get_grid</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a561517d815dd1004e1c39557554eee16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a068d8968ac1846a9ea5af7ca2defaf79" title="Get the specified var.">get_var()</a>. <br /></td></tr>
<tr class="separator:a561517d815dd1004e1c39557554eee16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0269a914a3e4e5465a7e3643785544"><td class="memItemLeft" align="right" valign="top"><a id="a9a0269a914a3e4e5465a7e3643785544"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> std::vector&lt; <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a9a0269a914a3e4e5465a7e3643785544">get_grids</a> ()</td></tr>
<tr class="memdesc:a9a0269a914a3e4e5465a7e3643785544"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a0d1cd86caa28951a816f8c7959351155" title="Get all the vars.">get_vars()</a>. <br /></td></tr>
<tr class="separator:a9a0269a914a3e4e5465a7e3643785544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea58c62d7f65d2bf1c13626d7d8d2dc6"><td class="memItemLeft" align="right" valign="top"><a id="aea58c62d7f65d2bf1c13626d7d8d2dc6"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#aea58c62d7f65d2bf1c13626d7d8d2dc6">new_grid</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;dims)</td></tr>
<tr class="memdesc:aea58c62d7f65d2bf1c13626d7d8d2dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a>. <br /></td></tr>
<tr class="separator:aea58c62d7f65d2bf1c13626d7d8d2dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30606c931e4b30a1d4d1b515dc4c5926"><td class="memItemLeft" align="right" valign="top"><a id="a30606c931e4b30a1d4d1b515dc4c5926"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a30606c931e4b30a1d4d1b515dc4c5926">new_grid</a> (const std::string &amp;name, const std::initializer_list&lt; std::string &gt; &amp;dims)</td></tr>
<tr class="memdesc:a30606c931e4b30a1d4d1b515dc4c5926"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a>. <br /></td></tr>
<tr class="separator:a30606c931e4b30a1d4d1b515dc4c5926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2481f6fed01aab4c1aa8fe478053162b"><td class="memItemLeft" align="right" valign="top"><a id="a2481f6fed01aab4c1aa8fe478053162b"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a2481f6fed01aab4c1aa8fe478053162b">new_fixed_size_grid</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;dims, const std::vector&lt; <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> &gt; &amp;dim_sizes)</td></tr>
<tr class="memdesc:a2481f6fed01aab4c1aa8fe478053162b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">new_fixed_size_var()</a>. <br /></td></tr>
<tr class="separator:a2481f6fed01aab4c1aa8fe478053162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bfa9b004e6f6798fa6aeb8b9a82f01"><td class="memItemLeft" align="right" valign="top"><a id="ab9bfa9b004e6f6798fa6aeb8b9a82f01"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ab9bfa9b004e6f6798fa6aeb8b9a82f01">new_fixed_size_grid</a> (const std::string &amp;name, const std::initializer_list&lt; std::string &gt; &amp;dims, const std::vector&lt; <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> &gt; &amp;dim_sizes)</td></tr>
<tr class="memdesc:ab9bfa9b004e6f6798fa6aeb8b9a82f01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">new_fixed_size_var()</a>. <br /></td></tr>
<tr class="separator:ab9bfa9b004e6f6798fa6aeb8b9a82f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20126eb21acf5e61ac2c94d823a34e1"><td class="memItemLeft" align="right" valign="top"><a id="ac20126eb21acf5e61ac2c94d823a34e1"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac20126eb21acf5e61ac2c94d823a34e1">fuse_grids</a> (<a class="el" href="group__yk.html#ga2debaa7135bb46dfc295ca623bee2876">yk_solution_ptr</a> source)</td></tr>
<tr class="memdesc:ac20126eb21acf5e61ac2c94d823a34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yk__solution.html#a563794842445fcd96d77b463f674a60b" title="[Advanced] Merge YASK variables with another solution.">fuse_vars()</a>. <br /></td></tr>
<tr class="separator:ac20126eb21acf5e61ac2c94d823a34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stencil solution as defined by the generated code from the YASK stencil compiler. </p>
<p>Objects of this type contain all the vars and equations that comprise a solution.</p>
<p>Created via <a class="el" href="classyask_1_1yk__factory.html#a755b1bfc0dd9bfddfe80d924a188b350" title="Create a stencil solution.">yk_factory::new_solution()</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaafc0aa636a3d306e29771d5440c4aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafc0aa636a3d306e29771d5440c4aa4">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; yask::yk_solution::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the solution name provided during stencil compilation. </dd></dl>

</div>
</div>
<a id="ab25bbfab5dffc379bfb8c55ac64d6898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25bbfab5dffc379bfb8c55ac64d6898">&#9670;&nbsp;</a></span>get_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_solution::get_target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the target ISA. </p>
<dl class="section return"><dt>Returns</dt><dd>String describing the instruction-set architecture of the CPU targeted during kernel compilation. See the allowed YASK kernel targets in <a class="el" href="classyask_1_1yc__solution.html#a1c03fc69e306a700de8c5ae3973229c2" title="Set the output target.">yc_solution::set_target()</a>. </dd></dl>

</div>
</div>
<a id="a2978fb8fd701fe35ae8a8b19e23e5544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2978fb8fd701fe35ae8a8b19e23e5544">&#9670;&nbsp;</a></span>is_offloaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_solution::is_offloaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the stencil kernel will be offloaded to a device. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if kernel will be offloaded or <em>false</em> if not. </dd></dl>

</div>
</div>
<a id="a50e565487b7175447cc9f6489221eef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e565487b7175447cc9f6489221eef4">&#9670;&nbsp;</a></span>get_element_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_element_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the floating-point precision size. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in each FP element: 4 or 8. </dd></dl>

</div>
</div>
<a id="a7039e7151857e2652592a585c6d00931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7039e7151857e2652592a585c6d00931">&#9670;&nbsp;</a></span>get_step_dim_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_solution::get_step_dim_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the solution step dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the step-dimension name that was defined by <a class="el" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1" title="Create a step-index node.">yc_node_factory::new_step_index()</a> and used in one or more vars. </dd></dl>

</div>
</div>
<a id="a40a13017d8c3a599d00b99561405dd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a13017d8c3a599d00b99561405dd3c">&#9670;&nbsp;</a></span>get_num_domain_dims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_num_domain_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of domain dimensions used in this solution. </p>
<p>The domain dimensions are those over which the stencil is applied in each step. Does <em>not</em> include the step dimension or any miscellaneous dimensions. </p><dl class="section return"><dt>Returns</dt><dd>Number of dimensions that define the problem domain. </dd></dl>

</div>
</div>
<a id="a665968c18b2f70467dbc7decaeeb1a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665968c18b2f70467dbc7decaeeb1a1f">&#9670;&nbsp;</a></span>get_domain_dim_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; yask::yk_solution::get_domain_dim_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the domain dimension names. </p>
<dl class="section return"><dt>Returns</dt><dd>List of all domain-dimension names that were defined by <a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315" title="Create a domain-index node.">yc_node_factory::new_domain_index()</a> and used in one or more vars. </dd></dl>

</div>
</div>
<a id="af895e7366f7f224c4e6fc780b0dd7a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af895e7366f7f224c4e6fc780b0dd7a2f">&#9670;&nbsp;</a></span>get_misc_dim_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; yask::yk_solution::get_misc_dim_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the miscellaneous dimension names. </p>
<dl class="section return"><dt>Returns</dt><dd>List of all dimension names that were either Defined by <a class="el" href="classyask_1_1yc__node__factory.html#aef5fed8db0e1798b421c4a8cb8da77ff" title="Create a new miscellaneous index.">yc_node_factory::new_misc_index()</a> and used in one or more vars, or Created at run-time by adding a new dimension via <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">yk_solution::new_var()</a> or <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a>. </dd></dl>

</div>
</div>
<a id="a155d8f4a38da9da11488a18cca50bae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155d8f4a38da9da11488a18cca50bae8">&#9670;&nbsp;</a></span>set_rank_domain_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_rank_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that is in this rank. </p>
<p>The domain defines the number of elements that will be evaluated with the stencil(s). If MPI is not enabled, this is equivalent to the global-domain size. If MPI is enabled, this is the domain size for the current rank only, and the global-domain size is the sum of all local-domain sizes in each dimension. The local-domain size in each rank does not have to be the same, but all local-domains in the same column of ranks must have the same width, all local-domains in the same row must have the same height, and so forth, for each domain dimension. The local-domain size does <em>not</em> include the halo area or any padding. For best performance, set the local-domain size to a multiple of the number of elements in a vector-cluster in each dimension.</p>
<p>You should set either the local-domain size or the global-domain size in each dimension. The unspecified (zero) sizes will be calculated based on the specified ones when <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called. Setting the local-domain size to a non-zero value will clear the global-domain size in that dimension until <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called.</p>
<p>See the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a> for more information on var sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in the domain in this `dim`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56ba31268cb0098b64e4503c8996300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ba31268cb0098b64e4503c8996300f">&#9670;&nbsp;</a></span>get_rank_domain_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_rank_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local-domain size in the specified dimension, i.e., the size in this rank. </p>
<p>See documentation for <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that i...">set_rank_domain_size()</a>.</p>
<p>If you have called <a class="el" href="classyask_1_1yk__solution.html#a7f9a22d8d2b760a05307e90147d18d8c" title="Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks.">set_overall_domain_size()</a> in a given dimension, <a class="el" href="classyask_1_1yk__solution.html#a56ba31268cb0098b64e4503c8996300f" title="Get the local-domain size in the specified dimension, i.e., the size in this rank.">get_rank_domain_size()</a> will return zero in that dimension until <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called. After <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called, the computed size will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of rank domain size in specified dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f9a22d8d2b760a05307e90147d18d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9a22d8d2b760a05307e90147d18d8c">&#9670;&nbsp;</a></span>set_overall_domain_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_overall_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks. </p>
<p>You should set either the local-domain size or the global-domain size in each dimension. The unspecified (zero) sizes will be calculated based on the specified ones when <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called. Setting the global-domain size to a non-zero value will clear the local-domain size in that dimension until <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called.</p>
<p>See documentation for <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that i...">set_rank_domain_size()</a>. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a> for more information on var sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in the domain in this `dim`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba39cb06c9f61d408695009667fe8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba39cb06c9f61d408695009667fe8cd">&#9670;&nbsp;</a></span>get_overall_domain_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_overall_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks. </p>
<p>The global-domain indices in the specified dimension will range from zero (0) to <a class="el" href="classyask_1_1yk__solution.html#aaba39cb06c9f61d408695009667fe8cd" title="Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks.">get_overall_domain_size()</a> - 1, inclusive. Call <a class="el" href="classyask_1_1yk__solution.html#a03bdef5ba9b0b0e37f9b7be2e2e457a4" title="Get the first index of the sub-domain in this rank in the specified dimension.">get_first_rank_domain_index()</a> and <a class="el" href="classyask_1_1yk__solution.html#a58f2ce95e150787bc8235e85298dcd01" title="Get the last index of the sub-domain in this rank the specified dimension.">get_last_rank_domain_index()</a> to find the subset of this domain in each rank.</p>
<p>If you have called <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that i...">set_rank_domain_size()</a> in a given dimension, <a class="el" href="classyask_1_1yk__solution.html#aaba39cb06c9f61d408695009667fe8cd" title="Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks.">get_overall_domain_size()</a> will return zero in that dimension until <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called. After <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called, the computed size will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Sum of all ranks' domain sizes in the given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd3c7317bf1b397f332962d658f38839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3c7317bf1b397f332962d658f38839">&#9670;&nbsp;</a></span>set_block_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_block_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the block size in the given dimension. </p>
<p>This sets the approximate number of elements that are evaluated in each "block". This is a performance setting and should not affect the functional correctness or total number of elements evaluated. A block is typically the unit of work done by a top-level OpenMP thread. The actual number of elements evaluated in a block may be greater than the specified size due to rounding up to fold-cluster sizes. The number of elements in a block may also be smaller than the specified size when the block is at the edge of the domain. The block size cannot be set in the solution-step dimension (because temporal blocking is not yet enabled).</p>
<p>Unless auto-tuning is disabled, the block size will be used as a starting point for an automated search for a higher-performing block size.</p>
<p>This and all other tile sizes (Mega-blocks, blocks, micro-blocks, etc.) can be set via <a class="el" href="classyask_1_1yk__solution.html#ac111abbade055c4923cd0044360ec3b7" title="Set kernel options from a string.">apply_command_line_options()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a7039e7151857e2652592a585c6d00931" title="Get the solution step dimension.">get_step_dim_name()</a> or <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in a block in this `dim`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a601aeebc023d430a311788c3ce73c190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601aeebc023d430a311788c3ce73c190">&#9670;&nbsp;</a></span>get_block_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_block_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block size. </p>
<p>Returned value may be slightly larger than the value provided via <a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839" title="Set the block size in the given dimension.">set_block_size()</a> due to rounding. </p><dl class="section return"><dt>Returns</dt><dd>Current settings of block size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a7039e7151857e2652592a585c6d00931" title="Get the solution step dimension.">get_step_dim_name()</a> or <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4cd27d412b6fe013db58b167999a362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cd27d412b6fe013db58b167999a362">&#9670;&nbsp;</a></span>set_num_ranks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_num_ranks </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of MPI ranks in the given dimension. </p>
<p>If <a class="el" href="classyask_1_1yk__solution.html#ac4cd27d412b6fe013db58b167999a362" title="Set the number of MPI ranks in the given dimension.">set_num_ranks()</a> is set to a non-zero value in all dimensions, then the <em>product</em> of the number of ranks across all dimensions must equal the value returned by <a class="el" href="classyask_1_1yk__env.html#add8b12cd6d10f964665a41acedbb9b14" title="Get number of MPI ranks.">yk_env::get_num_ranks()</a>. If the number of ranks is zero in one or more dimensions, those values will be set by a heuristic when <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called. An exception will be thrown if no legal values are possible given the specified (non-zero) values.</p>
<p>The curent MPI rank will be assigned a unique location within the overall problem domain based on its MPI rank index. Or, you can set it explicitly via <a class="el" href="classyask_1_1yk__solution.html#ac0eccaa1d228d7f3408e3c2b0881f279" title="Set the rank index in the specified dimension.">set_rank_index()</a>.</p>
<p>The same number of MPI ranks must be set via this API on each constituent MPI rank to ensure a consistent overall configuration. The number of ranks in each dimension must be properly set before calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>. There is no rank setting allowed in the solution-step dimension (usually "t") or in a misc dimension.</p>
<p>In fact, a practical definition of a domain dimension is one that is decomposable across MPI ranks. Specifically, a domain dimension does not have to correspond to a spatial dimension in the physical problem description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of ranks in `dim`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4449fe8902881c9a61ad12fd20a5a866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4449fe8902881c9a61ad12fd20a5a866">&#9670;&nbsp;</a></span>get_num_ranks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_num_ranks </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of MPI ranks in the given dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of rank size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0eccaa1d228d7f3408e3c2b0881f279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eccaa1d228d7f3408e3c2b0881f279">&#9670;&nbsp;</a></span>set_rank_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_rank_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the rank index in the specified dimension. </p>
<p>The overall rank index in the specified dimension must range from zero (0) to <a class="el" href="classyask_1_1yk__solution.html#a4449fe8902881c9a61ad12fd20a5a866" title="Get the number of MPI ranks in the given dimension.">get_num_ranks()</a> - 1, inclusive. If you do not call <a class="el" href="classyask_1_1yk__solution.html#ac0eccaa1d228d7f3408e3c2b0881f279" title="Set the rank index in the specified dimension.">set_rank_index()</a>, a rank index will be assigned when <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> is called. You should either call <a class="el" href="classyask_1_1yk__solution.html#ac0eccaa1d228d7f3408e3c2b0881f279" title="Set the rank index in the specified dimension.">set_rank_index()</a> on all ranks or allow YASK to assign on on all ranks, i.e., do not mix-and-match.</p>
<p>Example using 6 MPI ranks in a 2-by-3 x, y domain:</p>
<table class="doxtable">
<tr>
<td>MPI rank index = 0, x rank index = 0, y rank index = 0 </td><td>MPI rank index = 1, x rank index = 1, y rank index = 0 </td></tr>
<tr>
<td>MPI rank index = 2, x rank index = 0, y rank index = 1 </td><td>MPI rank index = 3, x rank index = 1, y rank index = 1 </td></tr>
<tr>
<td>MPI rank index = 4, x rank index = 0, y rank index = 2 </td><td>MPI rank index = 5, x rank index = 1, y rank index = 2 </td></tr>
</table>
<p>See <a class="el" href="classyask_1_1yk__env.html#add8b12cd6d10f964665a41acedbb9b14" title="Get number of MPI ranks.">yk_env::get_num_ranks()</a> and <a class="el" href="classyask_1_1yk__env.html#a93deb7b62612742f5a85fd8e319df38c" title="Get MPI rank index.">yk_env::get_rank_index()</a> for MPI rank index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Rank index in `dim`. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3268e5e7e2f0e45f951f1c38063bc59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3268e5e7e2f0e45f951f1c38063bc59f">&#9670;&nbsp;</a></span>get_rank_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_rank_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank index in the specified dimension. </p>
<p>The overall rank index in the specified dimension will range from zero (0) to <a class="el" href="classyask_1_1yk__solution.html#a4449fe8902881c9a61ad12fd20a5a866" title="Get the number of MPI ranks in the given dimension.">get_num_ranks()</a> - 1, inclusive. </p><dl class="section return"><dt>Returns</dt><dd>Zero-based index of this rank. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac111abbade055c4923cd0044360ec3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac111abbade055c4923cd0044360ec3b7">&#9670;&nbsp;</a></span>apply_command_line_options() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_solution::apply_command_line_options </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set kernel options from a string. </p>
<p>Parses the string for options as if from a command-line. Example: "-bx 64 -block_threads 4" sets the block-size in the <em>x</em> dimension to 64 and the number of threads used to process each block to 4. See the help message from the YASK kernel binary for documentation on the command-line options. Used to set less-common options not directly supported by the APIs above (<a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839" title="Set the block size in the given dimension.">set_block_size()</a>, etc.).</p>
<dl class="section return"><dt>Returns</dt><dd>Any parts of <code>args</code> that were not recognized by the parser as options. Thus, a non-empty returned string may be used to signal an error or interpreted by a custom application in another way. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>String of arguments to parse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0947c4ad4ed06d8a7d5058daecd5dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0947c4ad4ed06d8a7d5058daecd5dc7">&#9670;&nbsp;</a></span>apply_command_line_options() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_solution::apply_command_line_options </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set kernel options from standard C or C++ <code>argc</code> and <code>argv</code> parameters to <code>main()</code>. </p>
<p>Discards <code>argv[0]</code>, which is the executable name. Then, parses the remaining <code>argv</code> values for options as described in <a class="el" href="classyask_1_1yk__solution.html#ac111abbade055c4923cd0044360ec3b7" title="Set kernel options from a string.">apply_command_line_options()</a> with a string argument.</p>
<dl class="section return"><dt>Returns</dt><dd>Any parts of <code>argv</code> that were not recognized by the parser as options. </dd></dl>

</div>
</div>
<a id="a6c128cbf16d4d4ab36c30654cd0e9818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c128cbf16d4d4ab36c30654cd0e9818">&#9670;&nbsp;</a></span>apply_command_line_options() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_solution::apply_command_line_options </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set kernel options from a vector of strings. </p>
<p>Parses <code>args</code> values for options as described in <a class="el" href="classyask_1_1yk__solution.html#ac111abbade055c4923cd0044360ec3b7" title="Set kernel options from a string.">apply_command_line_options()</a> with a string argument.</p>
<dl class="section return"><dt>Returns</dt><dd>Any parts of <code>args</code> that were not recognized by the parser as options. </dd></dl>

</div>
</div>
<a id="a9e0947f98bcea19c6400bcdf95ddf585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0947f98bcea19c6400bcdf95ddf585">&#9670;&nbsp;</a></span>get_num_vars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_num_vars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vars in the solution. </p>
<p>Vars may be pre-defined by the stencil compiler (e.g., via <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a>) or created explicitly via <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">yk_solution::new_var()</a> or <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Number of YASK vars that have been created. </dd></dl>

</div>
</div>
<a id="a068d8968ac1846a9ea5af7ca2defaf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068d8968ac1846a9ea5af7ca2defaf79">&#9670;&nbsp;</a></span>get_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> yask::yk_solution::get_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the specified var. </p>
<p>This cannot be used to access scratch vars. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the specified var or null pointer if it does not exist. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d1cd86caa28951a816f8c7959351155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1cd86caa28951a816f8c7959351155">&#9670;&nbsp;</a></span>get_vars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&gt; yask::yk_solution::get_vars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vars. </p>
<dl class="section return"><dt>Returns</dt><dd>List of all non-scratch vars in the solution. </dd></dl>

</div>
</div>
<a id="aa0edfde033c251e3f8d2d184a682d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0edfde033c251e3f8d2d184a682d4cb">&#9670;&nbsp;</a></span>prepare_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::prepare_solution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the solution for stencil application. </p>
<p>Allocates data in vars that do not already have storage allocated. Calculates the position of each rank in the overall problem domain. Sets many other data structures needed for proper stencil application. Since this function initiates MPI communication, it must be called on all MPI ranks, and it will block until all ranks have completed. Must be called before applying any stencils. </p>

</div>
</div>
<a id="a03bdef5ba9b0b0e37f9b7be2e2e457a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bdef5ba9b0b0e37f9b7be2e2e457a4">&#9670;&nbsp;</a></span>get_first_rank_domain_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_first_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of the sub-domain in this rank in the specified dimension. </p>
<p>This returns the first <em>overall</em> index at the beginning of the domain. Elements within the domain in this rank lie between the values returned by <a class="el" href="classyask_1_1yk__solution.html#a03bdef5ba9b0b0e37f9b7be2e2e457a4" title="Get the first index of the sub-domain in this rank in the specified dimension.">get_first_rank_domain_index()</a> and <a class="el" href="classyask_1_1yk__solution.html#a58f2ce95e150787bc8235e85298dcd01" title="Get the last index of the sub-domain in this rank the specified dimension.">get_last_rank_domain_index()</a>, inclusive. If there is only one MPI rank, this is typically zero (0). If there is more than one MPI rank, the value depends on the the rank's position within the overall problem domain.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> because <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>First domain index in this rank. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58f2ce95e150787bc8235e85298dcd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f2ce95e150787bc8235e85298dcd01">&#9670;&nbsp;</a></span>get_last_rank_domain_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_last_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of the sub-domain in this rank the specified dimension. </p>
<p>This returns the last <em>overall</em> index within the domain in this rank (<em>not</em> one past the end). If there is only one MPI rank, this is typically one less than the value provided by <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that i...">set_rank_domain_size()</a>. If there is more than one MPI rank, the value depends on the the rank's position within the overall problem domain. See <a class="el" href="classyask_1_1yk__solution.html#a03bdef5ba9b0b0e37f9b7be2e2e457a4" title="Get the first index of the sub-domain in this rank in the specified dimension.">get_first_rank_domain_index()</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> because <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a> assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Last index in this rank. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14cc5625fc524fe8eb8d3cedc66778aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14cc5625fc524fe8eb8d3cedc66778aa">&#9670;&nbsp;</a></span>run_solution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::run_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>first_step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>last_step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the stencil solution for the specified steps. </p>
<p>The stencil(s) in the solution are applied to the var data, setting the index variables as follows:</p><ol type="1">
<li>If temporal tiling is <em>not</em> used (the default):<ul>
<li>The step index (e.g., <code>t</code> for "time") will be sequentially set to values from <code>first_step_index</code> to <code>last_step_index</code>, inclusive.<ul>
<li>If the stencil equations were defined with dependencies on lower-valued steps, e.g., <code>t+1</code> depends on <code>t</code>, then <code>last_step_index</code> should be greater than or equal to <code>first_step_index</code> (forward solution).</li>
<li>If the stencil equations were defined with dependencies on higher-valued steps, e.g., <code>t-1</code> depends on <code>t</code>, then <code>last_step_index</code> should be less than or equal to <code>first_step_index</code> (reverse solution).</li>
</ul>
</li>
<li>For each step index, the domain indices will be set to values across the entire domain as returned by <a class="el" href="classyask_1_1yk__solution.html#aaba39cb06c9f61d408695009667fe8cd" title="Get the global-domain size in the specified dimension, i.e., the total size across all MPI ranks.">yk_solution::get_overall_domain_size()</a> (not necessarily sequentially).</li>
<li>MPI halo exchanges will occur as necessary before or during each step.</li>
<li>Since this function initiates MPI communication, it must be called on all MPI ranks, and it will block until all ranks have completed.</li>
</ul>
</li>
<li><b>[Advanced]</b> If temporal wave-front tiling <em>is</em> enabled:<ul>
<li>The step index (e.g., <code>t</code> for "time") will be sequentially set to values from <code>first_step_index</code> to <code>last_step_index</code>, inclusive, within each area configured for temporal tiling.<ul>
<li>The number of steps in an area may also be restricted by the size of the area in the step dimension. In that case, tiles will be done in temporal slices of that size.</li>
</ul>
</li>
<li>For each step index within each area, the domain indices will be set to values across the entire area (not necessarily sequentially).</li>
<li>Ultimately, the stencil(s) will be applied to same the elements in both the step and domain dimensions as when wave-front tiling is not used.</li>
<li>MPI halo exchanges may occur at less frequent intervals.</li>
</ul>
</li>
</ol>
<p>This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_step_index</td><td>First index in the step dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_step_index</td><td>Last index in the step dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46dc15b38732b30c820ffd7765292342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dc15b38732b30c820ffd7765292342">&#9670;&nbsp;</a></span>run_solution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::run_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>step_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the stencil solution for the specified step. </p>
<p>This function is simply an alias for <code>run_solution(step_index, step_index)</code>, i.e., the solution will be applied for exactly one step across the domain.</p>
<p>Typical C++ usage:</p>
<div class="fragment"><div class="line">soln-&gt;prepare_solution();</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> t = 1; t &lt;= num_steps; t++)</div><div class="line">    soln-&gt;run_solution(t);</div><div class="line">soln-&gt;end_solution();</div></div><!-- fragment --><p>As written, the above loop is identical to</p>
<div class="fragment"><div class="line">soln-&gt;prepare_solution();</div><div class="line">soln-&gt;run_solution(1, num_steps);</div><div class="line">soln-&gt;end_solution();</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The parameter is <em>not</em> the number of steps to run. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since only one step is taken per call, using this function effectively disables wave-front tiling. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step_index</td><td>Index in the step dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cdea230253b47bd16c1a0c326a78df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdea230253b47bd16c1a0c326a78df8">&#9670;&nbsp;</a></span>copy_vars_to_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::copy_vars_to_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update data on the device. </p>
<p>Copies any YASK var data that has been modified on the host but not on the device from the host to the device.</p>
<p>This is done automatically as needed, so calling this function is only needed when you want to control when the copy is done.</p>
<p>If the kernel has been compiled for offloading using unified shared memory, calling this function will have no effect. Similarly, if the kernel has not been compiled for offloading, calling this function will have no effect. </p>

</div>
</div>
<a id="a105c993241498d9c2a98cbec353fc61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105c993241498d9c2a98cbec353fc61a">&#9670;&nbsp;</a></span>copy_vars_from_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::copy_vars_from_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update data on the host. </p>
<p>Copies any YASK var data that has been modified on the device but not on the host from the device to the host.</p>
<p>This is done automatically as needed, so calling this function is only needed when you want to control when the copy is done.</p>
<p>If the kernel has been compiled for offloading using unified shared memory, calling this function will have no effect. Similarly, if the kernel has not been compiled for offloading, calling this function will have no effect. </p>

</div>
</div>
<a id="afac6a33fe5d098d31a844f4eba654b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac6a33fe5d098d31a844f4eba654b19">&#9670;&nbsp;</a></span>end_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::end_solution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish using a solution. </p>
<p>Performs a final MPI halo exchange. Releases shared ownership of memory used by the vars. This will result in deallocating each memory block that is not referenced by another shared pointer. </p>

</div>
</div>
<a id="ab2755703f0d90aa4e3ef36093a1976f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2755703f0d90aa4e3ef36093a1976f5">&#9670;&nbsp;</a></span>get_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#ga12d1d46aeb01bd7509a8dc3251657f75">yk_stats_ptr</a> yask::yk_solution::get_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get performance statistics associated with preceding calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Side effect: resets all statistics, so each call returns only the elapsed time and counts since the previous call. </dd>
<dd>
Side effect: outputs stats in human-readable format to current debug output object. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to statistics object. </dd></dl>

</div>
</div>
<a id="a0f7eea6bfc844adcc584c2ca5c1f2ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7eea6bfc844adcc584c2ca5c1f2ba4">&#9670;&nbsp;</a></span>is_auto_tuner_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_solution::is_auto_tuner_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the auto-tuner is enabled on this rank. </p>
<p>The auto-tuner is enabled by default. It will become disabled after it has converged or after reset_auto_tuner(false) has been called. </p><dl class="section return"><dt>Returns</dt><dd>Whether the auto-tuner is still searching. </dd></dl>

</div>
</div>
<a id="ab3bd7e95ea13631954d92a638badfb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bd7e95ea13631954d92a638badfb2d">&#9670;&nbsp;</a></span>set_min_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum amount of padding for all vars. </p>
<p>This sets the minimum number of elements in each var that is reserved outside of the rank domain in the given dimension. This padding area can be used for required halo areas. At least the specified number of elements will be added to both sides, i.e., both "before" and "after" the domain.</p>
<p>The <em>actual</em> padding size will be the largest of the following values, additionally rounded up based on the vector-folding dimensions, cache-line alignment, and/or extensions needed for wave-front tiles:</p><ul>
<li>Halo size.</li>
<li>Value provided by any of the pad-size setting functions.</li>
</ul>
<p>The padding size cannot be changed after data storage has been allocated for a given var; attempted changes to the pad size for such vars will be ignored.</p>
<p>Use <a class="el" href="classyask_1_1yk__var.html#a370adca271068bd8952bbe9d1696a78a" title="[Advanced] Set the minimum left padding in the specified dimension.">yk_var::set_left_min_pad_size</a> and <a class="el" href="classyask_1_1yk__var.html#a02ee27a0c922e55def701d6efffc725c" title="[Advanced] Set the minimum right padding in the specified dimension.">yk_var::set_right_min_pad_size()</a> for individual setting of each var. Call <a class="el" href="classyask_1_1yk__var.html#a2a6b515ee0073b8ff35fb8bee47de00e" title="Get the actual left padding in the specified dimension.">yk_var::get_left_pad_size()</a> and <a class="el" href="classyask_1_1yk__var.html#a44d13a6f6925574545bd5594cecece43" title="Get the actual right padding in the specified dimension.">yk_var::get_right_pad_size()</a> to determine the actual padding sizes for a given var. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a> for more information on var sizes. Padding is only allowed in the domain dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in this `dim` applied to both sides of the domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a193d7c6e708c1ece4d78b39800a7d5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193d7c6e708c1ece4d78b39800a7d5fa">&#9670;&nbsp;</a></span>get_min_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_solution::get_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the minimum amount of padding for all vars. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of minimum amount of padding for all vars. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a665968c18b2f70467dbc7decaeeb1a1f" title="Get all the domain dimension names.">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a932fad2ede1aecef168189c0aa972b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932fad2ede1aecef168189c0aa972b0b">&#9670;&nbsp;</a></span>reset_auto_tuner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::reset_auto_tuner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Restart or disable the auto-tuner on this rank. </p>
<p>Under normal operation, an auto-tuner is invoked automatically during calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a>. Currently, only the block size is set by the auto-tuner, and the search begins from the sizes set via <a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839" title="Set the block size in the given dimension.">set_block_size()</a> or the default size if <a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839" title="Set the block size in the given dimension.">set_block_size()</a> has not been called. This function is used to apply the current best-known settings if the tuner has been running, reset the state of the auto-tuner, and either restart its search or disable it from running. This call must be made on each rank where the change is desired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>If _true_, start or restart the auto-tuner search. If _false_, disable the auto-tuner from running. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If _true_, print progress information to the debug object set via <a class="el" href="classyask_1_1yk__solution.html#a7e8ce77d85b54ebaf15ddf11009066c4" title="[Deprecated] Use yk_env::set_debug_output().">set_debug_output()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e92afeb1d201ea0174fa04029ec0077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e92afeb1d201ea0174fa04029ec0077">&#9670;&nbsp;</a></span>run_auto_tuner_now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::run_auto_tuner_now </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Automatically tune selected settings immediately. </p>
<p>Executes a search algorithm to find [locally] optimum values for some of the settings. Under normal operation, an auto-tuner is invoked during calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a>. See <a class="el" href="classyask_1_1yk__solution.html#a932fad2ede1aecef168189c0aa972b0b" title="[Advanced] Restart or disable the auto-tuner on this rank.">reset_auto_tuner()</a> for more information. This function causes the stencil solution to be run immediately until the auto-tuner converges on all ranks. It is useful for benchmarking, where performance is to be timed for a given number of steps after the best settings are found. This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">prepare_solution()</a>. This call must be made on each rank. </p><dl class="section warning"><dt>Warning</dt><dd>Modifies the contents of the vars by calling <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a> an arbitrary number of times, but without halo exchange. (See <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a> for other restrictions and warnings.) Thus, var data should be set <em>after</em> calling this function when used in a production or test setting where correct results are expected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If _true_, print progress information to the debug object set via <a class="el" href="classyask_1_1yk__solution.html#a7e8ce77d85b54ebaf15ddf11009066c4" title="[Deprecated] Use yk_env::set_debug_output().">set_debug_output()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a076e1cc78d96e7cc77ec62d58e289131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076e1cc78d96e7cc77ec62d58e289131">&#9670;&nbsp;</a></span>new_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> yask::yk_solution::new_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new var to the solution. </p>
<p>This is typically not needed because vars used by the stencils are pre-defined by the solution itself via the stencil compiler. However, a var may be created explicitly via this function in order to use it for purposes other than by the pre-defined stencils within the current solution.</p>
<p>Vars created by this function will behave [mostly] like a pre-defined var. For example,</p><ul>
<li>Step and domain dimensions must the same as those defined by <a class="el" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1" title="Create a step-index node.">yc_node_factory::new_step_index()</a> and <a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315" title="Create a domain-index node.">yc_node_factory::new_domain_index()</a>, respectively.</li>
<li>For each domain dimension of the var, the new var's domain size will be the same as that returned by <a class="el" href="classyask_1_1yk__solution.html#a56ba31268cb0098b64e4503c8996300f" title="Get the local-domain size in the specified dimension, i.e., the size in this rank.">get_rank_domain_size()</a>.</li>
<li>Calls to <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that i...">set_rank_domain_size()</a> will automatically resize the corresponding domain size in this var.</li>
<li>This var's first domain index in this rank will be determined by the position of this rank.</li>
<li>This var's initial padding size will be the same as that returned by <a class="el" href="classyask_1_1yk__solution.html#a193d7c6e708c1ece4d78b39800a7d5fa" title="[Advanced] Get the minimum amount of padding for all vars.">get_min_pad_size()</a>.</li>
<li>After creating a new var, you can increase its padding sizes in the domain dimensions via <a class="el" href="classyask_1_1yk__var.html#a16aad88dc481991cbe83da7a55cb3799" title="[Advanced] Set the minimum padding in the specified dimension.">yk_var::set_min_pad_size()</a>, <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of padding for all vars.">yk_solution::set_min_pad_size()</a>, etc.</li>
<li>For step and misc dimensions, you can change the desired size <a class="el" href="classyask_1_1yk__var.html#a7bc339345cc04bb349e2f6bf586a29f1" title="[Advanced] Set the number of elements to allocate in the specified dimension.">yk_var::set_alloc_size()</a>.</li>
<li>Storage may be allocated via <a class="el" href="classyask_1_1yk__var.html#aa3b479a98b425c3a8d504145972198e0" title="[Advanced] Explicitly allocate data-storage memory for this var.">yk_var::alloc_storage()</a> or <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>.</li>
</ul>
<p>Some behaviors are different from pre-defined vars. For example,</p><ul>
<li>You can create new "misc" dimensions during var creation simply by naming them in the <code>dims</code> argument. Any dimension name that is not a step or domain dimension will become a misc dimension, whether or not it was defined via <a class="el" href="classyask_1_1yc__node__factory.html#aef5fed8db0e1798b421c4a8cb8da77ff" title="Create a new miscellaneous index.">yc_node_factory::new_misc_index()</a>.</li>
<li>Vars created via <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a> cannot be direct inputs or outputs of stencil equations. However, data in a var created via <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a> can be merged with a pre-defined var via <a class="el" href="classyask_1_1yk__var.html#aa095607d5493fcba38cb332053155b7f" title="[Advanced] Merge this var with another var.">yk_var::fuse_vars()</a> if the vars are compatible.</li>
</ul>
<p>If you want a var that is not automatically resized based on the solution settings, use <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">new_fixed_size_var()</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>A new var contains only the meta-data for the var; data storage is not yet allocated. Storage may be allocated in any of the methods listed in the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new var. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the var; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2774f810be2d57a878884111cbd36e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2774f810be2d57a878884111cbd36e9">&#9670;&nbsp;</a></span>new_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> yask::yk_solution::new_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new var to the solution. </p>
<p>See documentation for the version of <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a> with a vector of dimension names as a parameter. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in the Python API. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new var. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the var; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70c44ba3941aa5682e381c7c36dcf453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c44ba3941aa5682e381c7c36dcf453">&#9670;&nbsp;</a></span>new_fixed_size_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> yask::yk_solution::new_fixed_size_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new var to the solution with a specified size. </p>
<p>This is typically not needed because vars used by the stencils are pre-defined by the solution itself via the stencil compiler. However, a var may be created explicitly via this function in order to use it for purposes other than by the pre-defined stencils within the current solution.</p>
<p>The following behaviors are different from both pre-defined vars and those created via <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a>:</p><ul>
<li>Calls to <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that i...">set_rank_domain_size()</a> will <em>not</em> automatically resize the corresponding local-domain size in this var&ndash;this is where the term "fixed" applies.</li>
<li>In contrast, for each domain dimension of the var, the new var's local-domain size can be changed independently of the domain size of the solution.</li>
<li>This var's first domain index in this rank will be fixed at zero (0) in each domain dimension regardless of this rank's position. In other words, this var does not participate in "domain decomposition".</li>
<li>This var's padding size will be affected only by calls to <a class="el" href="classyask_1_1yk__var.html#a16aad88dc481991cbe83da7a55cb3799" title="[Advanced] Set the minimum padding in the specified dimension.">yk_var::set_min_pad_size()</a>, etc., i.e., <em>not</em> via <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of padding for all vars.">yk_solution::set_min_pad_size()</a>.</li>
</ul>
<p>The following behaviors are the same as those of a pre-defined var and those created via <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a>:</p><ul>
<li>For step and misc dimensions, you can change the desired size <a class="el" href="classyask_1_1yk__var.html#a7bc339345cc04bb349e2f6bf586a29f1" title="[Advanced] Set the number of elements to allocate in the specified dimension.">yk_var::set_alloc_size()</a>.</li>
<li>Storage may be allocated via <a class="el" href="classyask_1_1yk__var.html#aa3b479a98b425c3a8d504145972198e0" title="[Advanced] Explicitly allocate data-storage memory for this var.">yk_var::alloc_storage()</a> or <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>.</li>
</ul>
<p>See <a class="el" href="classyask_1_1yk__var.html#a7bc339345cc04bb349e2f6bf586a29f1" title="[Advanced] Set the number of elements to allocate in the specified dimension.">yk_var::set_alloc_size()</a>.</p>
<p>The following behaviors are different than a pre-defined var but the same as those created via <a class="el" href="classyask_1_1yk__solution.html#a076e1cc78d96e7cc77ec62d58e289131" title="[Advanced] Add a new var to the solution.">new_var()</a>:</p><ul>
<li>You can create new "misc" dimensions during var creation simply by naming them in the <code>dims</code> argument. Any dimension name that is not a step or domain dimension will become a misc dimension, whether or not it was defined via <a class="el" href="classyask_1_1yc__node__factory.html#aef5fed8db0e1798b421c4a8cb8da77ff" title="Create a new miscellaneous index.">yc_node_factory::new_misc_index()</a>.</li>
<li>Vars created via <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">new_fixed_size_var()</a> cannot be direct inputs or outputs of stencil equations. However, data in a var created via <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">new_fixed_size_var()</a> can be shared with a pre-defined var via <a class="el" href="classyask_1_1yk__var.html#aa095607d5493fcba38cb332053155b7f" title="[Advanced] Merge this var with another var.">yk_var::fuse_vars()</a> if the vars are compatible.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A new var contains only the meta-data for the var; data storage is not yet allocated. Storage may be allocated in any of the methods listed in the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new var. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the var; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this var. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_sizes</td><td>Initial allocation in each dimension. Must be exatly one size for each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b682d609950a4d9b9d8fb497aad9971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b682d609950a4d9b9d8fb497aad9971">&#9670;&nbsp;</a></span>new_fixed_size_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> yask::yk_solution::new_fixed_size_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new var to the solution with a specified size. </p>
<p>See documentation for the version of <a class="el" href="classyask_1_1yk__solution.html#a70c44ba3941aa5682e381c7c36dcf453" title="[Advanced] Add a new var to the solution with a specified size.">new_fixed_size_var()</a> with a vector of dimension names as a parameter. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in the Python API. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new var. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the var; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this var. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_sizes</td><td>Initial allocation in each dimension. Must be exatly one size for each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8bde8dfc73219cec84ad3033faabb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bde8dfc73219cec84ad3033faabb90">&#9670;&nbsp;</a></span>set_default_numa_preferred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_solution::set_default_numa_preferred </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numa_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data. </p>
<p>This value is used when allocating vars and MPI buffers. The NUMA "preferred node allocation" policy is used, meaning that memory will be allocated in an alternative node if the preferred one doesn't have enough space available or is otherwise restricted. Instead of specifying a NUMA node, a special value may be used to specify another policy as listed. This setting may be overridden for any specific var. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if NUMA preference was set; <code>false</code> if NUMA preferences are not enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numa_node</td><td>Preferred NUMA node for data allocation. Alternatively, use `yask_numa_local` for explicit local-node allocation, `yask_numa_interleave` for interleaving pages across all nodes, or `yask_numa_none` for no explicit NUMA policy. These constants are defined in the _Variable Documentation_ section of <a class="el" href="yk__solution__api_8hpp.html">yk_solution_api.hpp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05c98a1d8b03d1009ef67b84b2f0bea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c98a1d8b03d1009ef67b84b2f0bea0">&#9670;&nbsp;</a></span>get_default_numa_preferred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_default_numa_preferred </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of preferred NUMA node. </dd></dl>

</div>
</div>
<a id="aeaa3d7e75bfcde066f1ea8b2871ced4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa3d7e75bfcde066f1ea8b2871ced4b">&#9670;&nbsp;</a></span>call_before_prepare_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::call_before_prepare_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyask_1_1yk__solution.html#a913e7b208c46bbad2115784332bc303d">hook_fn_t</a>&#160;</td>
          <td class="paramname"><em>hook_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Register a function to be called at the beginning of <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>. </p>
<p>A reference to the <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> is passed to the <code>hook_fn</code>.</p>
<p>If this method is called more than once, the hook functions will be called in the order registered.</p>
<dl class="section note"><dt>Note</dt><dd>Not available in the Python API. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_fn</td><td>callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cfa2c38e2ecbac19a989cc771b68627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfa2c38e2ecbac19a989cc771b68627">&#9670;&nbsp;</a></span>call_after_prepare_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::call_after_prepare_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyask_1_1yk__solution.html#a913e7b208c46bbad2115784332bc303d">hook_fn_t</a>&#160;</td>
          <td class="paramname"><em>hook_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Register a hook function to be called at the end of <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>. </p>
<p>A reference to the <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> is passed to the <code>hook_fn</code>.</p>
<p>If this method is called more than once, the hook functions will be called in the order registered.</p>
<dl class="section note"><dt>Note</dt><dd>Not available in the Python API. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_fn</td><td>callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2291f79959831dcc378443c8f1152fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2291f79959831dcc378443c8f1152fc9">&#9670;&nbsp;</a></span>call_before_run_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::call_before_run_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyask_1_1yk__solution.html#a1c2a4d0fdf7e975885eb638a3e192cf3">hook_fn_2idx_t</a>&#160;</td>
          <td class="paramname"><em>hook_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Register a hook function to be called at the beginning of <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">yk_solution::run_solution()</a>. </p>
<p>A reference to the <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> and the <code>first_step_index</code> and <code>last_step_index</code> passed to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a> are passed to the <code>hook_fn</code>.</p>
<p>If this method is called more than once, the hook functions will be called in the order registered.</p>
<dl class="section note"><dt>Note</dt><dd>Not available in the Python API. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_fn</td><td>callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a527715f33d673b45c4a833caa4de9d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527715f33d673b45c4a833caa4de9d9e">&#9670;&nbsp;</a></span>call_after_run_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::call_after_run_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyask_1_1yk__solution.html#a1c2a4d0fdf7e975885eb638a3e192cf3">hook_fn_2idx_t</a>&#160;</td>
          <td class="paramname"><em>hook_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Register a hook function to be called at the end of <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">yk_solution::run_solution()</a>. </p>
<p>A reference to the <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> and the <code>first_step_index</code> and <code>last_step_index</code> passed to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">run_solution()</a> are passed to the <code>hook_fn</code>.</p>
<p>If this method is called more than once, the hook functions will be called in the order registered.</p>
<dl class="section note"><dt>Note</dt><dd>Not available in the Python API. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_fn</td><td>callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a563794842445fcd96d77b463f674a60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563794842445fcd96d77b463f674a60b">&#9670;&nbsp;</a></span>fuse_vars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::fuse_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yk.html#ga2debaa7135bb46dfc295ca623bee2876">yk_solution_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Merge YASK variables with another solution. </p>
<p>Calls <a class="el" href="classyask_1_1yk__var.html#aa095607d5493fcba38cb332053155b7f" title="[Advanced] Merge this var with another var.">yk_var::fuse_vars()</a> for each pair of vars that have the same name in this solution and the source solution. All conditions listed in <a class="el" href="classyask_1_1yk__var.html#aa095607d5493fcba38cb332053155b7f" title="[Advanced] Merge this var with another var.">yk_var::fuse_vars()</a> must hold for each pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Solution from which vars will be merged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9b7c6f23e3190f3958fa1843fd0cba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b7c6f23e3190f3958fa1843fd0cba0">&#9670;&nbsp;</a></span>set_step_wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_step_wrap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set whether invalid step indices alias to valid ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">do_wrap</td><td>Whether to allow any step index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9cf6be2225ae2273b921b85dd8c7ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cf6be2225ae2273b921b85dd8c7ac5">&#9670;&nbsp;</a></span>get_step_wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_solution::get_step_wrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get whether invalid step indices alias to valid ones. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether any step index is allowed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="yk__solution__api_8hpp_source.html">yk_solution_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
