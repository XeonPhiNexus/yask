<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YASK: yask::yk_var Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kit: a software framework for creating HPC stencil code. Copyright 2014-2019 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yask</b></li><li class="navelem"><a class="el" href="classyask_1_1yk__var.html">yk_var</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyask_1_1yk__var-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yask::yk_var Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__yk.html">YASK Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A run-time YASK data container.  
 <a href="classyask_1_1yk__var.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="yk__var__api_8hpp_source.html">yk_var_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4dd64a662a1711fe5613e58773ea0fba"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a4dd64a662a1711fe5613e58773ea0fba">get_name</a> () const =0</td></tr>
<tr class="memdesc:a4dd64a662a1711fe5613e58773ea0fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the var.  <a href="#a4dd64a662a1711fe5613e58773ea0fba">More...</a><br /></td></tr>
<tr class="separator:a4dd64a662a1711fe5613e58773ea0fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c3bbc2bea32b76a9dda612fa91f0f4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aa6c3bbc2bea32b76a9dda612fa91f0f4">get_num_dims</a> () const =0</td></tr>
<tr class="memdesc:aa6c3bbc2bea32b76a9dda612fa91f0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions used in this var.  <a href="#aa6c3bbc2bea32b76a9dda612fa91f0f4">More...</a><br /></td></tr>
<tr class="separator:aa6c3bbc2bea32b76a9dda612fa91f0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2e93317a2e86d80713ad56a46fdc68"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga53bde373152f3af12ba9daa06007eb5f">string_vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68">get_dim_names</a> () const =0</td></tr>
<tr class="memdesc:adf2e93317a2e86d80713ad56a46fdc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the dimensions in this var.  <a href="#adf2e93317a2e86d80713ad56a46fdc68">More...</a><br /></td></tr>
<tr class="separator:adf2e93317a2e86d80713ad56a46fdc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace776bc0e51b07e940b23ebbce7a2232"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ace776bc0e51b07e940b23ebbce7a2232">is_dim_used</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:ace776bc0e51b07e940b23ebbce7a2232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether specified dimension exists in this var.  <a href="#ace776bc0e51b07e940b23ebbce7a2232">More...</a><br /></td></tr>
<tr class="separator:ace776bc0e51b07e940b23ebbce7a2232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420e0dde2114ba663069b16d579072eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a420e0dde2114ba663069b16d579072eb">is_fixed_size</a> () const =0</td></tr>
<tr class="memdesc:a420e0dde2114ba663069b16d579072eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this var is <em>not</em> automatically resized based on the solution.  <a href="#a420e0dde2114ba663069b16d579072eb">More...</a><br /></td></tr>
<tr class="separator:a420e0dde2114ba663069b16d579072eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5b3f06b832bbf77b8f722fda8a2998"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aaf5b3f06b832bbf77b8f722fda8a2998">get_first_local_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:aaf5b3f06b832bbf77b8f722fda8a2998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first valid index in this rank in the specified dimension.  <a href="#aaf5b3f06b832bbf77b8f722fda8a2998">More...</a><br /></td></tr>
<tr class="separator:aaf5b3f06b832bbf77b8f722fda8a2998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266bb36c93cb6ae538a0f081f22fad7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a7266bb36c93cb6ae538a0f081f22fad7">get_last_local_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a7266bb36c93cb6ae538a0f081f22fad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index in this rank in the specified dimension.  <a href="#a7266bb36c93cb6ae538a0f081f22fad7">More...</a><br /></td></tr>
<tr class="separator:a7266bb36c93cb6ae538a0f081f22fad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1934db25d379b5ae2366e01a88a2c867"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a1934db25d379b5ae2366e01a88a2c867">get_alloc_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a1934db25d379b5ae2366e01a88a2c867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements allocated in the specified dimension.  <a href="#a1934db25d379b5ae2366e01a88a2c867">More...</a><br /></td></tr>
<tr class="separator:a1934db25d379b5ae2366e01a88a2c867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a02011041f38a4d2fe7899d5369511e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a6a02011041f38a4d2fe7899d5369511e">get_first_valid_step_index</a> () const =0</td></tr>
<tr class="memdesc:a6a02011041f38a4d2fe7899d5369511e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first valid index in the step dimension.  <a href="#a6a02011041f38a4d2fe7899d5369511e">More...</a><br /></td></tr>
<tr class="separator:a6a02011041f38a4d2fe7899d5369511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b346e48cb36b0f304d3b030ac9a1512"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a7b346e48cb36b0f304d3b030ac9a1512">get_last_valid_step_index</a> () const =0</td></tr>
<tr class="memdesc:a7b346e48cb36b0f304d3b030ac9a1512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last valid index in the step dimension.  <a href="#a7b346e48cb36b0f304d3b030ac9a1512">More...</a><br /></td></tr>
<tr class="separator:a7b346e48cb36b0f304d3b030ac9a1512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb132fe3e1f813a0c22b1366e5d55ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a3eb132fe3e1f813a0c22b1366e5d55ad">get_rank_domain_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a3eb132fe3e1f813a0c22b1366e5d55ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the domain size for this rank.  <a href="#a3eb132fe3e1f813a0c22b1366e5d55ad">More...</a><br /></td></tr>
<tr class="separator:a3eb132fe3e1f813a0c22b1366e5d55ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8b63ef869693d7eeb556e5254d167"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a60d8b63ef869693d7eeb556e5254d167">get_first_rank_domain_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a60d8b63ef869693d7eeb556e5254d167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of the sub-domain in this rank in the specified dimension.  <a href="#a60d8b63ef869693d7eeb556e5254d167">More...</a><br /></td></tr>
<tr class="separator:a60d8b63ef869693d7eeb556e5254d167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3e835c074a2bdd627f76483727b1dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aaf3e835c074a2bdd627f76483727b1dc">get_last_rank_domain_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:aaf3e835c074a2bdd627f76483727b1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of the sub-domain in this rank in the specified dimension.  <a href="#aaf3e835c074a2bdd627f76483727b1dc">More...</a><br /></td></tr>
<tr class="separator:aaf3e835c074a2bdd627f76483727b1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8e51e7ee79fcc55a622b3012da63bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#acd8e51e7ee79fcc55a622b3012da63bc">get_left_halo_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:acd8e51e7ee79fcc55a622b3012da63bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the left halo size in the specified dimension.  <a href="#acd8e51e7ee79fcc55a622b3012da63bc">More...</a><br /></td></tr>
<tr class="separator:acd8e51e7ee79fcc55a622b3012da63bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1b9954909e58d6f12c2c9d8296005e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aeb1b9954909e58d6f12c2c9d8296005e">get_right_halo_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:aeb1b9954909e58d6f12c2c9d8296005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right halo size in the specified dimension.  <a href="#aeb1b9954909e58d6f12c2c9d8296005e">More...</a><br /></td></tr>
<tr class="separator:aeb1b9954909e58d6f12c2c9d8296005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363c78d8f7f5b40581fb0cb179058410"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a363c78d8f7f5b40581fb0cb179058410">get_first_rank_halo_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a363c78d8f7f5b40581fb0cb179058410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of the left halo in this rank in the specified dimension.  <a href="#a363c78d8f7f5b40581fb0cb179058410">More...</a><br /></td></tr>
<tr class="separator:a363c78d8f7f5b40581fb0cb179058410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d97b360b0b1e4c5785adf87384c41e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ad3d97b360b0b1e4c5785adf87384c41e">get_last_rank_halo_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:ad3d97b360b0b1e4c5785adf87384c41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of the right halo in this rank in the specified dimension.  <a href="#ad3d97b360b0b1e4c5785adf87384c41e">More...</a><br /></td></tr>
<tr class="separator:ad3d97b360b0b1e4c5785adf87384c41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6b515ee0073b8ff35fb8bee47de00e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a2a6b515ee0073b8ff35fb8bee47de00e">get_left_pad_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a2a6b515ee0073b8ff35fb8bee47de00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual left padding in the specified dimension.  <a href="#a2a6b515ee0073b8ff35fb8bee47de00e">More...</a><br /></td></tr>
<tr class="separator:a2a6b515ee0073b8ff35fb8bee47de00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d13a6f6925574545bd5594cecece43"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a44d13a6f6925574545bd5594cecece43">get_right_pad_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a44d13a6f6925574545bd5594cecece43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual right padding in the specified dimension.  <a href="#a44d13a6f6925574545bd5594cecece43">More...</a><br /></td></tr>
<tr class="separator:a44d13a6f6925574545bd5594cecece43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62308be69ca643714879b0a1362de0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ae62308be69ca643714879b0a1362de0e">get_left_extra_pad_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:ae62308be69ca643714879b0a1362de0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual extra left padding in the specified dimension.  <a href="#ae62308be69ca643714879b0a1362de0e">More...</a><br /></td></tr>
<tr class="separator:ae62308be69ca643714879b0a1362de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6845890c3f22bf4614f1f57f414501"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#afe6845890c3f22bf4614f1f57f414501">get_right_extra_pad_size</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:afe6845890c3f22bf4614f1f57f414501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual extra right padding in the specified dimension.  <a href="#afe6845890c3f22bf4614f1f57f414501">More...</a><br /></td></tr>
<tr class="separator:afe6845890c3f22bf4614f1f57f414501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faab903ed2467e46ed0b5ea43a9e1e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a9faab903ed2467e46ed0b5ea43a9e1e4">get_first_misc_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a9faab903ed2467e46ed0b5ea43a9e1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of a specified miscellaneous dimension.  <a href="#a9faab903ed2467e46ed0b5ea43a9e1e4">More...</a><br /></td></tr>
<tr class="separator:a9faab903ed2467e46ed0b5ea43a9e1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab551b0a8749c38e8307082631cf597fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ab551b0a8749c38e8307082631cf597fa">get_last_misc_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:ab551b0a8749c38e8307082631cf597fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of a specified miscellaneous dimension.  <a href="#ab551b0a8749c38e8307082631cf597fa">More...</a><br /></td></tr>
<tr class="separator:ab551b0a8749c38e8307082631cf597fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc808533b7c6e34614409d34bec1a86"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a3cc808533b7c6e34614409d34bec1a86">are_indices_local</a> (const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;indices) const =0</td></tr>
<tr class="memdesc:a3cc808533b7c6e34614409d34bec1a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given indices refer to an accessible element in this rank.  <a href="#a3cc808533b7c6e34614409d34bec1a86">More...</a><br /></td></tr>
<tr class="separator:a3cc808533b7c6e34614409d34bec1a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923c12a1a7b80698c09f2447828416ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a923c12a1a7b80698c09f2447828416ed">are_indices_local</a> (const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;indices) const =0</td></tr>
<tr class="memdesc:a923c12a1a7b80698c09f2447828416ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given indices refer to an accessible element in this rank.  <a href="#a923c12a1a7b80698c09f2447828416ed">More...</a><br /></td></tr>
<tr class="separator:a923c12a1a7b80698c09f2447828416ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2d676221d5b99be7b8b8bc2cd37af2"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aed2d676221d5b99be7b8b8bc2cd37af2">get_element</a> (const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;indices) const =0</td></tr>
<tr class="memdesc:aed2d676221d5b99be7b8b8bc2cd37af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of one element in this var.  <a href="#aed2d676221d5b99be7b8b8bc2cd37af2">More...</a><br /></td></tr>
<tr class="separator:aed2d676221d5b99be7b8b8bc2cd37af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49bd859b3200e8cd8a55fe55ecbde93"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#af49bd859b3200e8cd8a55fe55ecbde93">get_element</a> (const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;indices) const =0</td></tr>
<tr class="memdesc:af49bd859b3200e8cd8a55fe55ecbde93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of one element in this var.  <a href="#af49bd859b3200e8cd8a55fe55ecbde93">More...</a><br /></td></tr>
<tr class="separator:af49bd859b3200e8cd8a55fe55ecbde93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac509cdab014c58033c15b5c92f4bb7d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ac509cdab014c58033c15b5c92f4bb7d6">set_element</a> (double val, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;indices, bool strict_indices=true)=0</td></tr>
<tr class="memdesc:ac509cdab014c58033c15b5c92f4bb7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of one element in this var.  <a href="#ac509cdab014c58033c15b5c92f4bb7d6">More...</a><br /></td></tr>
<tr class="separator:ac509cdab014c58033c15b5c92f4bb7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a5e0c4f28ef714f1de855ddb81877d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a42a5e0c4f28ef714f1de855ddb81877d">set_element</a> (double val, const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;indices, bool strict_indices=true)=0</td></tr>
<tr class="memdesc:a42a5e0c4f28ef714f1de855ddb81877d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of one element in this var.  <a href="#a42a5e0c4f28ef714f1de855ddb81877d">More...</a><br /></td></tr>
<tr class="separator:a42a5e0c4f28ef714f1de855ddb81877d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33ae6d7f03ec5fb8fa31e4ad9ff7881"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ad33ae6d7f03ec5fb8fa31e4ad9ff7881">get_elements_in_slice</a> (void *buffer_ptr, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;first_indices, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;last_indices) const =0</td></tr>
<tr class="memdesc:ad33ae6d7f03ec5fb8fa31e4ad9ff7881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements within specified subset of this var into a buffer.  <a href="#ad33ae6d7f03ec5fb8fa31e4ad9ff7881">More...</a><br /></td></tr>
<tr class="separator:ad33ae6d7f03ec5fb8fa31e4ad9ff7881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac79a05181b3eee1031e27cfc0d2c145"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aac79a05181b3eee1031e27cfc0d2c145">add_to_element</a> (double val, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;indices, bool strict_indices=true)=0</td></tr>
<tr class="memdesc:aac79a05181b3eee1031e27cfc0d2c145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add to the value of one var element.  <a href="#aac79a05181b3eee1031e27cfc0d2c145">More...</a><br /></td></tr>
<tr class="separator:aac79a05181b3eee1031e27cfc0d2c145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4832584daca2f5139b8a8ba93bcf6a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#adf4832584daca2f5139b8a8ba93bcf6a">add_to_element</a> (double val, const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;indices, bool strict_indices=true)=0</td></tr>
<tr class="memdesc:adf4832584daca2f5139b8a8ba93bcf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add to the value of one var element.  <a href="#adf4832584daca2f5139b8a8ba93bcf6a">More...</a><br /></td></tr>
<tr class="separator:adf4832584daca2f5139b8a8ba93bcf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbfa0153ac69dfadf0e655246ddeac2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a0cbfa0153ac69dfadf0e655246ddeac2">set_all_elements_same</a> (double val)=0</td></tr>
<tr class="memdesc:a0cbfa0153ac69dfadf0e655246ddeac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all var elements to the same value.  <a href="#a0cbfa0153ac69dfadf0e655246ddeac2">More...</a><br /></td></tr>
<tr class="separator:a0cbfa0153ac69dfadf0e655246ddeac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad919afb54bbde78938a3939e76df0cd8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ad919afb54bbde78938a3939e76df0cd8">set_elements_in_slice_same</a> (double val, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;first_indices, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;last_indices, bool strict_indices=true)=0</td></tr>
<tr class="memdesc:ad919afb54bbde78938a3939e76df0cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize var elements within specified subset of the var to the same value.  <a href="#ad919afb54bbde78938a3939e76df0cd8">More...</a><br /></td></tr>
<tr class="separator:ad919afb54bbde78938a3939e76df0cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56798ab60559bd84fdc204d7255ebe46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a56798ab60559bd84fdc204d7255ebe46">set_elements_in_slice</a> (const void *buffer_ptr, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;first_indices, const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;last_indices)=0</td></tr>
<tr class="memdesc:a56798ab60559bd84fdc204d7255ebe46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set var elements within specified subset of the var from values in a buffer.  <a href="#a56798ab60559bd84fdc204d7255ebe46">More...</a><br /></td></tr>
<tr class="separator:a56798ab60559bd84fdc204d7255ebe46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d6c585b8384881065c01bb067c96dd"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a55d6c585b8384881065c01bb067c96dd">format_indices</a> (const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;indices) const =0</td></tr>
<tr class="memdesc:a55d6c585b8384881065c01bb067c96dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the indices for human-readable display.  <a href="#a55d6c585b8384881065c01bb067c96dd">More...</a><br /></td></tr>
<tr class="separator:a55d6c585b8384881065c01bb067c96dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae929dea5359d07e7541abab78ca7b139"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ae929dea5359d07e7541abab78ca7b139">format_indices</a> (const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;indices) const =0</td></tr>
<tr class="memdesc:ae929dea5359d07e7541abab78ca7b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the indices for human-readable display.  <a href="#ae929dea5359d07e7541abab78ca7b139">More...</a><br /></td></tr>
<tr class="separator:ae929dea5359d07e7541abab78ca7b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de3a290dae76a40b3c208074ebbdb89"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a2de3a290dae76a40b3c208074ebbdb89">get_halo_exchange_l1_norm</a> () const =0</td></tr>
<tr class="memdesc:a2de3a290dae76a40b3c208074ebbdb89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the maximum L1-norm of a neighbor rank for halo exchange.  <a href="#a2de3a290dae76a40b3c208074ebbdb89">More...</a><br /></td></tr>
<tr class="separator:a2de3a290dae76a40b3c208074ebbdb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f65d5983b3e8f16bb20c466d6b7f027"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a5f65d5983b3e8f16bb20c466d6b7f027">set_halo_exchange_l1_norm</a> (int norm)=0</td></tr>
<tr class="memdesc:a5f65d5983b3e8f16bb20c466d6b7f027"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the maximum L1-norm of a neighbor rank for halo exchange.  <a href="#a5f65d5983b3e8f16bb20c466d6b7f027">More...</a><br /></td></tr>
<tr class="separator:a5f65d5983b3e8f16bb20c466d6b7f027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4783735b2f5b72c659f1572c44598f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a9c4783735b2f5b72c659f1572c44598f">is_dynamic_step_alloc</a> () const =0</td></tr>
<tr class="memdesc:a9c4783735b2f5b72c659f1572c44598f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get whether the allocation of the step dimension of this var can be modified at run-time.  <a href="#a9c4783735b2f5b72c659f1572c44598f">More...</a><br /></td></tr>
<tr class="separator:a9c4783735b2f5b72c659f1572c44598f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f7d6f9bbe826eed31e6dc2be01de4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#ac68f7d6f9bbe826eed31e6dc2be01de4">set_numa_preferred</a> (int numa_node)=0</td></tr>
<tr class="memdesc:ac68f7d6f9bbe826eed31e6dc2be01de4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data.  <a href="#ac68f7d6f9bbe826eed31e6dc2be01de4">More...</a><br /></td></tr>
<tr class="separator:ac68f7d6f9bbe826eed31e6dc2be01de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052f304a6ac220ab43fc118172d33428"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a052f304a6ac220ab43fc118172d33428">get_numa_preferred</a> () const =0</td></tr>
<tr class="memdesc:a052f304a6ac220ab43fc118172d33428"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data.  <a href="#a052f304a6ac220ab43fc118172d33428">More...</a><br /></td></tr>
<tr class="separator:a052f304a6ac220ab43fc118172d33428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370adca271068bd8952bbe9d1696a78a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a370adca271068bd8952bbe9d1696a78a">set_left_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a370adca271068bd8952bbe9d1696a78a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum left padding in the specified dimension.  <a href="#a370adca271068bd8952bbe9d1696a78a">More...</a><br /></td></tr>
<tr class="separator:a370adca271068bd8952bbe9d1696a78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ee27a0c922e55def701d6efffc725c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a02ee27a0c922e55def701d6efffc725c">set_right_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a02ee27a0c922e55def701d6efffc725c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum right padding in the specified dimension.  <a href="#a02ee27a0c922e55def701d6efffc725c">More...</a><br /></td></tr>
<tr class="separator:a02ee27a0c922e55def701d6efffc725c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aad88dc481991cbe83da7a55cb3799"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a16aad88dc481991cbe83da7a55cb3799">set_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a16aad88dc481991cbe83da7a55cb3799"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum padding in the specified dimension.  <a href="#a16aad88dc481991cbe83da7a55cb3799">More...</a><br /></td></tr>
<tr class="separator:a16aad88dc481991cbe83da7a55cb3799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89147504cd60e15520e1fa96c2ad5b76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a89147504cd60e15520e1fa96c2ad5b76">set_left_halo_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a89147504cd60e15520e1fa96c2ad5b76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the left halo size in the specified dimension.  <a href="#a89147504cd60e15520e1fa96c2ad5b76">More...</a><br /></td></tr>
<tr class="separator:a89147504cd60e15520e1fa96c2ad5b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d43cc66c47eb773c0e8aa043ec76099"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a6d43cc66c47eb773c0e8aa043ec76099">set_right_halo_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a6d43cc66c47eb773c0e8aa043ec76099"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the right halo size in the specified dimension.  <a href="#a6d43cc66c47eb773c0e8aa043ec76099">More...</a><br /></td></tr>
<tr class="separator:a6d43cc66c47eb773c0e8aa043ec76099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722269d4ddc542181858eec462afd38f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a722269d4ddc542181858eec462afd38f">set_halo_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a722269d4ddc542181858eec462afd38f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the left and right halo sizes in the specified dimension.  <a href="#a722269d4ddc542181858eec462afd38f">More...</a><br /></td></tr>
<tr class="separator:a722269d4ddc542181858eec462afd38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc339345cc04bb349e2f6bf586a29f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a7bc339345cc04bb349e2f6bf586a29f1">set_alloc_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a7bc339345cc04bb349e2f6bf586a29f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the number of elements to allocate in the specified dimension.  <a href="#a7bc339345cc04bb349e2f6bf586a29f1">More...</a><br /></td></tr>
<tr class="separator:a7bc339345cc04bb349e2f6bf586a29f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5beae21df987bf4a93bec2ebf8a423f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a5beae21df987bf4a93bec2ebf8a423f6">set_first_misc_index</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> idx)=0</td></tr>
<tr class="memdesc:a5beae21df987bf4a93bec2ebf8a423f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the first index of a specified miscellaneous dimension.  <a href="#a5beae21df987bf4a93bec2ebf8a423f6">More...</a><br /></td></tr>
<tr class="separator:a5beae21df987bf4a93bec2ebf8a423f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7ed5c0f513ae7a5480a480f08165b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#adb7ed5c0f513ae7a5480a480f08165b7">get_first_rank_alloc_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:adb7ed5c0f513ae7a5480a480f08165b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the first accessible index in this var in this rank in the specified domain dimension.  <a href="#adb7ed5c0f513ae7a5480a480f08165b7">More...</a><br /></td></tr>
<tr class="separator:adb7ed5c0f513ae7a5480a480f08165b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2919bd783fb240a9d0f43a866bf7f551"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a2919bd783fb240a9d0f43a866bf7f551">get_last_rank_alloc_index</a> (const std::string &amp;dim) const =0</td></tr>
<tr class="memdesc:a2919bd783fb240a9d0f43a866bf7f551"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the last accessible index in this var in this rank in the specified domain dimension.  <a href="#a2919bd783fb240a9d0f43a866bf7f551">More...</a><br /></td></tr>
<tr class="separator:a2919bd783fb240a9d0f43a866bf7f551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b09855a3cfa7e43c32fc43a24503340"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a3b09855a3cfa7e43c32fc43a24503340">is_storage_allocated</a> () const =0</td></tr>
<tr class="memdesc:a3b09855a3cfa7e43c32fc43a24503340"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine whether storage has been allocated.  <a href="#a3b09855a3cfa7e43c32fc43a24503340">More...</a><br /></td></tr>
<tr class="separator:a3b09855a3cfa7e43c32fc43a24503340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4741fd9f7413d5ad634c755a52ffc6b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a4741fd9f7413d5ad634c755a52ffc6b3">get_num_storage_bytes</a> () const =0</td></tr>
<tr class="memdesc:a4741fd9f7413d5ad634c755a52ffc6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine size of raw storage in bytes.  <a href="#a4741fd9f7413d5ad634c755a52ffc6b3">More...</a><br /></td></tr>
<tr class="separator:a4741fd9f7413d5ad634c755a52ffc6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73864906531e75762a4d0829b65cd997"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a73864906531e75762a4d0829b65cd997">get_num_storage_elements</a> () const =0</td></tr>
<tr class="memdesc:a73864906531e75762a4d0829b65cd997"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine size of raw storage in elements.  <a href="#a73864906531e75762a4d0829b65cd997">More...</a><br /></td></tr>
<tr class="separator:a73864906531e75762a4d0829b65cd997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b479a98b425c3a8d504145972198e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aa3b479a98b425c3a8d504145972198e0">alloc_storage</a> ()=0</td></tr>
<tr class="memdesc:aa3b479a98b425c3a8d504145972198e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Explicitly allocate data-storage memory for this var.  <a href="#aa3b479a98b425c3a8d504145972198e0">More...</a><br /></td></tr>
<tr class="separator:aa3b479a98b425c3a8d504145972198e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3a6024af940112404ad871dab63cdb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a9e3a6024af940112404ad871dab63cdb">release_storage</a> ()=0</td></tr>
<tr class="memdesc:a9e3a6024af940112404ad871dab63cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Explicitly release any allocated data-storage for this var.  <a href="#a9e3a6024af940112404ad871dab63cdb">More...</a><br /></td></tr>
<tr class="separator:a9e3a6024af940112404ad871dab63cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3611ad6d130cb5ee7e030e6ad0c24f5b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a3611ad6d130cb5ee7e030e6ad0c24f5b">is_storage_layout_identical</a> (const <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> other) const =0</td></tr>
<tr class="memdesc:a3611ad6d130cb5ee7e030e6ad0c24f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determines whether storage layout is the same as another var.  <a href="#a3611ad6d130cb5ee7e030e6ad0c24f5b">More...</a><br /></td></tr>
<tr class="separator:a3611ad6d130cb5ee7e030e6ad0c24f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa095607d5493fcba38cb332053155b7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#aa095607d5493fcba38cb332053155b7f">fuse_vars</a> (<a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a> source)=0</td></tr>
<tr class="memdesc:aa095607d5493fcba38cb332053155b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Merge this var with another var.  <a href="#aa095607d5493fcba38cb332053155b7f">More...</a><br /></td></tr>
<tr class="separator:aa095607d5493fcba38cb332053155b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e42c4cfc5b3b6a5d998611d0d8602"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__var.html#a4a4e42c4cfc5b3b6a5d998611d0d8602">get_raw_storage_buffer</a> ()=0</td></tr>
<tr class="memdesc:a4a4e42c4cfc5b3b6a5d998611d0d8602"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get pointer to raw data storage buffer.  <a href="#a4a4e42c4cfc5b3b6a5d998611d0d8602">More...</a><br /></td></tr>
<tr class="separator:a4a4e42c4cfc5b3b6a5d998611d0d8602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A run-time YASK data container. </p>
<p>A run-time YASK variable is a generic term for any n-dimensional array. A 0-dim var is a scalar, a 1-dim var is an array, etc. A run-time variable actually contains data, unlike <a class="el" href="classyask_1_1yc__var.html" title="A compile-time data variable.">yc_var</a>, a compile-time variable.</p>
<p>Typically, access to each var is obtained via <a class="el" href="classyask_1_1yk__solution.html#a068d8968ac1846a9ea5af7ca2defaf79" title="Get the specified var.">yk_solution::get_var()</a>. You may also use <a class="el" href="classyask_1_1yk__solution.html#a75ba824977414468dd23f0a1d5f9eaf3" title="[Advanced] Add a new var to the solution.">yk_solution::new_var()</a> or <a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a> if you need a var that is not part of the pre-defined solution.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Var Dimensions</h1>
<p>Each dimension of a YASK var is one of the following:</p><ul>
<li>The <em>step</em> dimension, typically time (<code>t</code>), as returned from <a class="el" href="classyask_1_1yk__solution.html#a7039e7151857e2652592a585c6d00931" title="Get the solution step dimension.">yk_solution::get_step_dim_name()</a>.</li>
<li>A <em>domain</em> dimension, typically a spatial dimension such as <code>x</code> or <code>y</code>, as returned from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>.</li>
<li>A <em>miscellaneous</em> dimension, which is any dimension that is not a step or domain dimension. These may be returned via <a class="el" href="classyask_1_1yk__solution.html#a4184ac69b5e5af07e8cfc0317d6bd759" title="Get all the miscellaneous dimension names.">yk_solution::get_misc_dim_names()</a> if they were defined in the YASK compiler, or they may be any other name that is not a step or domain dimension.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
Step Dimensions</h2>
<p>The step dimension, as defined during YASK compilation, is the dimension in which the simulation proceeds, often "t" for time. In the step dimension, there is no fixed first or last index. However, there is a finite allocation size, which is the number of values in the step dimension that are stored in memory. The valid indices in the step dimension are always consecutive and change based on what was last written to the var.</p>
<p>For example: If a var <code>A</code> has an allocation size of two (2) in the <code>t</code> step dimension, its initial valid <code>t</code> indices are 0 and 1. Calling <code>A-&gt;get_element({0, x})</code> or <code>A-&gt;get_element({1, x})</code> would return a value from <code>A</code> assuming <code>x</code> is a valid index, but <code>A-&gt;get_element({2, x})</code> would cause a run-time exception. Let's say the YASK solution defines <code>A(t+1, x) EQUALS (A(t, x) + A(t, x+1))/2</code>. Calling yk_solution::run_solution(1) means that <code>A(2, x)</code> would be defined for all <code>x</code> in the domain because <code>t+1 == 2</code> on the left-hand-side of the equation. Thus, the new valid <code>t</code> indices in <code>A</code> would be 1 and 2, and <code>A(0, x)</code> is no longer stored in memory because the allocation size is only 2. Then, calling <code>A-&gt;get_element({1, x})</code> or <code>A-&gt;get_element({2, x})</code> would succeed and <code>A-&gt;get_element({0, x})</code> would fail.</p>
<p>Calling APIs that set values in a var such as <a class="el" href="classyask_1_1yk__var.html#ac509cdab014c58033c15b5c92f4bb7d6" title="Set the value of one element in this var.">set_element()</a> will also update the valid step index range. The current valid indices in the step dimension can be retrieved via <a class="el" href="classyask_1_1yk__var.html#a6a02011041f38a4d2fe7899d5369511e" title="Get the first valid index in the step dimension.">yk_var::get_first_valid_step_index()</a> and <a class="el" href="classyask_1_1yk__var.html#a7b346e48cb36b0f304d3b030ac9a1512" title="Get the last valid index in the step dimension.">yk_var::get_last_valid_step_index()</a>.</p>
<p>If yk_solution::set_step_wrap(true) is called, any invalid value of a step index provided to an API will silently "wrap-around" to a valid value by effectively adding or subtracing multiples of the allocation size as needed. For example, if the valid step indices are 7 and 8 for a given var, the indices 0 and 1 will wrap-around to 8 and 7, respectively. This is not recommended for general use because it can hide off-by-one-type errors. However, it may be useful for applications that need to access a var using absolute rather than logical step indices.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Domain Dimensions</h2>
<p>A domain dimension typically corresponds to a physical spatial dimension, but it can be any dimension that is used for "domain decomposition" in the solution. The indices in the domain dimensions that correspond to spatial dimensions (e.g., "x" and "y") often denote locations in the implicit "grid" of the problem domain.</p>
<p>In each domain dimension, the number of elements allocated in a given var include the following components:</p><ul>
<li>The <em>domain</em> is the elements to which the stencils are applied.</li>
<li>The <em>left padding</em> is all the accessible elements before the domain and includes the left halo.</li>
<li>The <em>right padding</em> is all the accessible elements after the domain and includes the right halo.</li>
<li>The <em>left halo</em> is the elements just before the domain which must be copied between preceding ranks during halo exchanges. The left halo is contained within the left padding.</li>
<li>The <em>right halo</em> is the elements just after the domain which must be copied between following ranks during halo exchanges. The right halo is contained within the right padding.</li>
<li>The <em>extra left padding</em> is the elements before the domain and left halo and thus does not include the left halo.</li>
<li>The <em>extra right padding</em> is the elements after the domain and right halo and thus does not include the right halo.</li>
<li>The <em>allocation</em> includes the left padding, domain, and right padding.</li>
</ul>
<p>Domain sizes specified via <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the local-domain size in the specified dimension, i.e., the size of the part of the domain that i...">yk_solution::set_rank_domain_size()</a> apply to each MPI rank. Visually, in each of the domain dimensions, these sizes are related as follows in each rank: </p><table class="doxtable">
<tr>
<td>extra left padding </td><td>left halo </td><td rowspan="2">domain </td><td>right halo </td><td>extra right padding </td></tr>
<tr>
<td colspan="2"><center>left padding</center> </td><td colspan="2"><center>right padding</center> </td></tr>
<tr>
<td colspan="5"><center>allocation</center> </td></tr>
</table>
<p>If MPI is not enabled, a rank's domain is equivalent to the entire problem size. If MPI is enabled, the domains of the ranks are logically abutted to create the overall problem domain in each dimension: </p><table class="doxtable">
<tr>
<td>extra left padding of rank A </td><td>halo of rank A </td><td>domain of rank A </td><td>domain of rank B </td><td>... </td><td>domain of rank Z </td><td>halo of rank Z </td><td>extra right padding of rank Z </td></tr>
<tr>
<td colspan="2"><center>left padding of rank A</center> </td><td colspan="4"><center>overall problem domain</center> </td><td colspan="2"><center>right padding of rank Z</center> </td></tr>
</table>
<p>Halos and paddings between ranks also exist, but are not shown in the above diagram. The halos overlap the domains of adjacent ranks. For example, the left halo of rank B in the diagram would overlap the domain of rank A. Data in these overlapped areas are exchanged as needed during stencil application to maintain a consistent values as if there was only one rank.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Miscellaneous Dimensions</h2>
<p>In each miscellaneous dimension, there is no padding or halos. There is a fixed allocation size, and each index must be between its first and last valid value. The valid miscellaneous indices may be retrieved via <a class="el" href="classyask_1_1yk__var.html#a9faab903ed2467e46ed0b5ea43a9e1e4" title="Get the first index of a specified miscellaneous dimension.">yk_var::get_first_misc_index()</a> and <a class="el" href="classyask_1_1yk__var.html#ab551b0a8749c38e8307082631cf597fa" title="Get the last index of a specified miscellaneous dimension.">yk_var::get_last_misc_index()</a>.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Other Details</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Elements</h2>
<p>All sizes are expressed in numbers of elements. Each element may be a 4-byte (single precision) or 8-byte (double precision) floating-point value as returned by <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution::get_element_bytes()</a>.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Data Storage</h2>
<p>Initially, a var is not assigned any allocated storage. This is done to allow modification of domain, padding, and other allocation sizes before allocation. Once the allocation sizes have been set in all dimensions, the data storage itself may be allocated. This can be done in any of the following ways:</p><ul>
<li>Storage for all vars without data storage will be automatically allocated when <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a> is called.</li>
<li>Storage for a specific var may be allocated before calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a> via <a class="el" href="classyask_1_1yk__var.html#aa3b479a98b425c3a8d504145972198e0" title="[Advanced] Explicitly allocate data-storage memory for this var.">yk_var::alloc_storage()</a>.</li>
<li><b>[Advanced]</b> A var may be merged with another var with existing storage via <a class="el" href="classyask_1_1yk__var.html#aa095607d5493fcba38cb332053155b7f" title="[Advanced] Merge this var with another var.">yk_var::fuse_vars()</a>. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4dd64a662a1711fe5613e58773ea0fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd64a662a1711fe5613e58773ea0fba">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; yask::yk_var::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the var. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing name provided via <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a>, <a class="el" href="classyask_1_1yk__solution.html#a75ba824977414468dd23f0a1d5f9eaf3" title="[Advanced] Add a new var to the solution.">yk_solution::new_var()</a>, or <a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a>.. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Recall that scratch vars created via <a class="el" href="classyask_1_1yc__solution.html#ac025854d8d7a0e4c62753dda67ff9e39" title="Create an n-dimensional scratch variable in the solution.">yc_solution::new_scratch_var()</a> are temporary variables and thus are not accessible via the kernel APIs. </dd></dl>

</div>
</div>
<a id="aa6c3bbc2bea32b76a9dda612fa91f0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c3bbc2bea32b76a9dda612fa91f0f4">&#9670;&nbsp;</a></span>get_num_dims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_var::get_num_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of dimensions used in this var. </p>
<p>This may include domain, step, and/or miscellaneous dimensions. </p><dl class="section return"><dt>Returns</dt><dd>Number of dimensions created via <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a>, <a class="el" href="classyask_1_1yk__solution.html#a75ba824977414468dd23f0a1d5f9eaf3" title="[Advanced] Add a new var to the solution.">yk_solution::new_var()</a>, or <a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a>. </dd></dl>

</div>
</div>
<a id="adf2e93317a2e86d80713ad56a46fdc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2e93317a2e86d80713ad56a46fdc68">&#9670;&nbsp;</a></span>get_dim_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga53bde373152f3af12ba9daa06007eb5f">string_vec</a> yask::yk_var::get_dim_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the dimensions in this var. </p>
<p>This may include domain, step, and/or miscellaneous dimensions. </p><dl class="section return"><dt>Returns</dt><dd>List of names of all the dimensions. </dd></dl>

</div>
</div>
<a id="ace776bc0e51b07e940b23ebbce7a2232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace776bc0e51b07e940b23ebbce7a2232">&#9670;&nbsp;</a></span>is_dim_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::is_dim_used </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether specified dimension exists in this var. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if dimension exists (including step-dimension), <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a420e0dde2114ba663069b16d579072eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420e0dde2114ba663069b16d579072eb">&#9670;&nbsp;</a></span>is_fixed_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::is_fixed_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether this var is <em>not</em> automatically resized based on the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this var was created via <a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a> or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aaf5b3f06b832bbf77b8f722fda8a2998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5b3f06b832bbf77b8f722fda8a2998">&#9670;&nbsp;</a></span>get_first_local_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_first_local_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first valid index in this rank in the specified dimension. </p>
<p>This is a convenience function that provides the first possible index in any var dimension regardless of the dimension type. It is equivalent to get_first_rank_alloc_index(dim) when <code>dim</code> is a domain dimension, get_first_misc_index(dim) for a misc dimension, and <a class="el" href="classyask_1_1yk__var.html#a6a02011041f38a4d2fe7899d5369511e" title="Get the first valid index in the step dimension.">get_first_valid_step_index()</a> for the step dimension. </p><dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the first valid index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7266bb36c93cb6ae538a0f081f22fad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7266bb36c93cb6ae538a0f081f22fad7">&#9670;&nbsp;</a></span>get_last_local_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_last_local_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index in this rank in the specified dimension. </p>
<p>This is a convenience function that provides the last possible index in any var dimension regardless of the dimension type. It is equivalent to get_last_rank_alloc_index(dim) when <code>dim</code> is a domain dimension, get_last_misc_index(dim) for a misc dimension, and <a class="el" href="classyask_1_1yk__var.html#a7b346e48cb36b0f304d3b030ac9a1512" title="Get the last valid index in the step dimension.">get_last_valid_step_index()</a> for the step dimension. </p><dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the last valid index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1934db25d379b5ae2366e01a88a2c867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1934db25d379b5ae2366e01a88a2c867">&#9670;&nbsp;</a></span>get_alloc_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_alloc_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements allocated in the specified dimension. </p>
<p>For the domain dimensions, this includes the rank-domain and padding sizes. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a> for information on var sizes. For any dimension <code>dim</code>, <code>get_alloc_size(dim) == get_last_local_index(dim) - get_first_local_index(dim) + 1</code>; </p><dl class="section return"><dt>Returns</dt><dd>allocation in number of elements (not bytes). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a02011041f38a4d2fe7899d5369511e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a02011041f38a4d2fe7899d5369511e">&#9670;&nbsp;</a></span>get_first_valid_step_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_first_valid_step_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first valid index in the step dimension. </p>
<p>The valid step indices in a var are updated by calling <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">yk_solution::run_solution()</a> or one of the element-setting API functions. Equivalient to get_first_local_index(dim), where <code>dim</code> is the step dimension. </p><dl class="section return"><dt>Returns</dt><dd>the first index in the step dimension that can be used in one of the element-getting API functions. This var must use the step index. </dd></dl>

</div>
</div>
<a id="a7b346e48cb36b0f304d3b030ac9a1512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b346e48cb36b0f304d3b030ac9a1512">&#9670;&nbsp;</a></span>get_last_valid_step_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_last_valid_step_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last valid index in the step dimension. </p>
<p>The valid step indices in a var are updated by calling <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">yk_solution::run_solution()</a> or one of the element-setting API functions. Equivalient to get_last_local_index(dim), where <code>dim</code> is the step dimension. </p><dl class="section return"><dt>Returns</dt><dd>the last index in the step dimension that can be used in one of the element-getting API functions. This var must use the step index. </dd></dl>

</div>
</div>
<a id="a3eb132fe3e1f813a0c22b1366e5d55ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb132fe3e1f813a0c22b1366e5d55ad">&#9670;&nbsp;</a></span>get_rank_domain_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_rank_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the domain size for this rank. </p>
<dl class="section return"><dt>Returns</dt><dd>The same value as <a class="el" href="classyask_1_1yk__solution.html#a56ba31268cb0098b64e4503c8996300f" title="Get the local-domain size in the specified dimension, i.e., the size in this rank.">yk_solution::get_rank_domain_size()</a> if <a class="el" href="classyask_1_1yk__var.html#a420e0dde2114ba663069b16d579072eb" title="Determine whether this var is not automatically resized based on the solution.">is_fixed_size()</a> returns <code>false</code> or the fixed sized provided via <a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60d8b63ef869693d7eeb556e5254d167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d8b63ef869693d7eeb556e5254d167">&#9670;&nbsp;</a></span>get_first_rank_domain_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_first_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of the sub-domain in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as <a class="el" href="classyask_1_1yk__solution.html#a03bdef5ba9b0b0e37f9b7be2e2e457a4" title="Get the first index of the sub-domain in this rank in the specified dimension.">yk_solution::get_first_rank_domain_index()</a> if <a class="el" href="classyask_1_1yk__var.html#a420e0dde2114ba663069b16d579072eb" title="Determine whether this var is not automatically resized based on the solution.">is_fixed_size()</a> returns <code>false</code> or zero (0) otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf3e835c074a2bdd627f76483727b1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3e835c074a2bdd627f76483727b1dc">&#9670;&nbsp;</a></span>get_last_rank_domain_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_last_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of the sub-domain in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as <a class="el" href="classyask_1_1yk__solution.html#a58f2ce95e150787bc8235e85298dcd01" title="Get the last index of the sub-domain in this rank the specified dimension.">yk_solution::get_last_rank_domain_index()</a> if <a class="el" href="classyask_1_1yk__var.html#a420e0dde2114ba663069b16d579072eb" title="Determine whether this var is not automatically resized based on the solution.">is_fixed_size()</a> returns <code>false</code> or one less than the fixed sized provided via <a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd8e51e7ee79fcc55a622b3012da63bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8e51e7ee79fcc55a622b3012da63bc">&#9670;&nbsp;</a></span>get_left_halo_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_left_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the left halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler. </p><dl class="section return"><dt>Returns</dt><dd>Elements in halo in given dimension before the domain. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb1b9954909e58d6f12c2c9d8296005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1b9954909e58d6f12c2c9d8296005e">&#9670;&nbsp;</a></span>get_right_halo_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_right_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the right halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler. </p><dl class="section return"><dt>Returns</dt><dd>Elements in halo in given dimension after the domain. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a363c78d8f7f5b40581fb0cb179058410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363c78d8f7f5b40581fb0cb179058410">&#9670;&nbsp;</a></span>get_first_rank_halo_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_first_rank_halo_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of the left halo in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The first index of left halo in this rank or the same value as <a class="el" href="classyask_1_1yk__var.html#a60d8b63ef869693d7eeb556e5254d167" title="Get the first index of the sub-domain in this rank in the specified dimension.">yk_var::get_first_rank_domain_index()</a> if the left halo has zero size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3d97b360b0b1e4c5785adf87384c41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d97b360b0b1e4c5785adf87384c41e">&#9670;&nbsp;</a></span>get_last_rank_halo_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_last_rank_halo_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of the right halo in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last index of right halo in this rank or the same value as <a class="el" href="classyask_1_1yk__var.html#aaf3e835c074a2bdd627f76483727b1dc" title="Get the last index of the sub-domain in this rank in the specified dimension.">yk_var::get_last_rank_domain_index()</a> if the right halo has zero size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a6b515ee0073b8ff35fb8bee47de00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6b515ee0073b8ff35fb8bee47de00e">&#9670;&nbsp;</a></span>get_left_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_left_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the actual left padding in the specified dimension. </p>
<p>The left padding is the memory allocated before the domain in a given dimension. The left padding size includes the left halo size. The value may be slightly larger than that provided via <a class="el" href="classyask_1_1yk__var.html#a370adca271068bd8952bbe9d1696a78a" title="[Advanced] Set the minimum left padding in the specified dimension.">set_left_min_pad_size()</a>, etc. due to rounding. </p><dl class="section return"><dt>Returns</dt><dd>Elements in left padding in given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44d13a6f6925574545bd5594cecece43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d13a6f6925574545bd5594cecece43">&#9670;&nbsp;</a></span>get_right_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_right_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the actual right padding in the specified dimension. </p>
<p>The right padding is the memory allocated after the domain in a given dimension. The right padding size includes the right halo size. The value may be slightly larger than that provided via <a class="el" href="classyask_1_1yk__var.html#a02ee27a0c922e55def701d6efffc725c" title="[Advanced] Set the minimum right padding in the specified dimension.">set_right_min_pad_size()</a>, etc. due to rounding. </p><dl class="section return"><dt>Returns</dt><dd>Elements in right padding in given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae62308be69ca643714879b0a1362de0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62308be69ca643714879b0a1362de0e">&#9670;&nbsp;</a></span>get_left_extra_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_left_extra_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the actual extra left padding in the specified dimension. </p>
<p>The <em>extra</em> padding size is the left padding size minus the left halo size. </p><dl class="section return"><dt>Returns</dt><dd>Elements in padding in given dimension before the left halo area. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe6845890c3f22bf4614f1f57f414501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6845890c3f22bf4614f1f57f414501">&#9670;&nbsp;</a></span>get_right_extra_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_right_extra_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the actual extra right padding in the specified dimension. </p>
<p>The <em>extra</em> padding size is the right padding size minus the right halo size. </p><dl class="section return"><dt>Returns</dt><dd>Elements in padding in given dimension after the right halo area. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9faab903ed2467e46ed0b5ea43a9e1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faab903ed2467e46ed0b5ea43a9e1e4">&#9670;&nbsp;</a></span>get_first_misc_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_first_misc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of a specified miscellaneous dimension. </p>
<p>Equivalent to get_first_local_index(dim), where <code>dim</code> is a misc dimension. </p><dl class="section return"><dt>Returns</dt><dd>the first valid index in a non-step and non-domain dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a4184ac69b5e5af07e8cfc0317d6bd759" title="Get all the miscellaneous dimension names.">yk_solution::get_misc_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab551b0a8749c38e8307082631cf597fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab551b0a8749c38e8307082631cf597fa">&#9670;&nbsp;</a></span>get_last_misc_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_last_misc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of a specified miscellaneous dimension. </p>
<p>Equivalent to get_last_local_index(dim), where <code>dim</code> is a misc dimension. </p><dl class="section return"><dt>Returns</dt><dd>the last valid index in a non-step and non-domain dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a4184ac69b5e5af07e8cfc0317d6bd759" title="Get all the miscellaneous dimension names.">yk_solution::get_misc_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cc808533b7c6e34614409d34bec1a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc808533b7c6e34614409d34bec1a86">&#9670;&nbsp;</a></span>are_indices_local() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::are_indices_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the given indices refer to an accessible element in this rank. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a> for this var. Domain index values are relative to the <em>overall</em> problem domain. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if index values fall within the range returned by get_first_local_index(dim) and get_last_local_index(dim) for each dimension <code>dim</code> in the var; <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a923c12a1a7b80698c09f2447828416ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923c12a1a7b80698c09f2447828416ed">&#9670;&nbsp;</a></span>are_indices_local() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::are_indices_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the given indices refer to an accessible element in this rank. </p>
<p>See <a class="el" href="classyask_1_1yk__var.html#a3cc808533b7c6e34614409d34bec1a86" title="Determine whether the given indices refer to an accessible element in this rank.">are_indices_local()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed2d676221d5b99be7b8b8bc2cd37af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2d676221d5b99be7b8b8bc2cd37af2">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double yask::yk_var::get_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the value of one element in this var. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall between the values returned by <a class="el" href="classyask_1_1yk__var.html#aaf5b3f06b832bbf77b8f722fda8a2998" title="Get the first valid index in this rank in the specified dimension.">get_first_local_index()</a> and <a class="el" href="classyask_1_1yk__var.html#a7266bb36c93cb6ae538a0f081f22fad7" title="Get the last index in this rank in the specified dimension.">get_last_local_index()</a>, inclusive, for each dimension in the var. </p><dl class="section return"><dt>Returns</dt><dd>value in var at given indices. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af49bd859b3200e8cd8a55fe55ecbde93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49bd859b3200e8cd8a55fe55ecbde93">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double yask::yk_var::get_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the value of one element in this var. </p>
<p>See <a class="el" href="classyask_1_1yk__var.html#aed2d676221d5b99be7b8b8bc2cd37af2" title="Read the value of one element in this var.">get_element()</a>. </p><dl class="section return"><dt>Returns</dt><dd>value in var at given indices. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac509cdab014c58033c15b5c92f4bb7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac509cdab014c58033c15b5c92f4bb7d6">&#9670;&nbsp;</a></span>set_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::set_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of one element in this var. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. If the var uses the step dimension, the value of the step index will be used to update the current valid step indices in the var. If <code>strict_indices</code> is <code>false</code> and any non-step index values are invalid as defined by <a class="el" href="classyask_1_1yk__var.html#a3cc808533b7c6e34614409d34bec1a86" title="Determine whether the given indices refer to an accessible element in this rank.">are_indices_local()</a>, the API will have no effect and return zero (0). If <code>strict_indices</code> is <code>true</code> and any non-step index values are invalid, the API will throw an exception. If storage has not been allocated for this var, this will have no effect and return zero (0) if <code>strict_indices</code> is <code>false</code>, or it will throw an exception if <code>strict_indices</code> is <code>true</code>. </p><dl class="section note"><dt>Note</dt><dd>The parameter value is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution::get_element_bytes()</a> returns 4. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements set, which will be one (1) if the indices are valid and zero (0) if they are not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Element in var will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42a5e0c4f28ef714f1de855ddb81877d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a5e0c4f28ef714f1de855ddb81877d">&#9670;&nbsp;</a></span>set_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::set_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of one element in this var. </p>
<p>See <a class="el" href="classyask_1_1yk__var.html#ac509cdab014c58033c15b5c92f4bb7d6" title="Set the value of one element in this var.">set_element()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Element in var will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad33ae6d7f03ec5fb8fa31e4ad9ff7881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33ae6d7f03ec5fb8fa31e4ad9ff7881">&#9670;&nbsp;</a></span>get_elements_in_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_elements_in_slice </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>first_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>last_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy elements within specified subset of this var into a buffer. </p>
<p>Reads all elements from <code>first_indices</code> to <code>last_indices</code> in each dimension and writes them to consecutive memory locations in the buffer. Indices in the buffer progress in row-major order, i.e., traditional C-language layout. The buffer pointed to must contain the number of bytes equal to <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution::get_element_bytes()</a> multiplied by the number of elements in the specified slice. Since the reads proceed in row-major order, the last index is "unit-stride" in the buffer.</p>
<p>Provide indices in two lists in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall between the values returned by <a class="el" href="classyask_1_1yk__var.html#aaf5b3f06b832bbf77b8f722fda8a2998" title="Get the first valid index in this rank in the specified dimension.">get_first_local_index()</a> and <a class="el" href="classyask_1_1yk__var.html#a7266bb36c93cb6ae538a0f081f22fad7" title="Get the last index in this rank in the specified dimension.">get_last_local_index()</a>, inclusive. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements read. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_ptr</td><td>Pointer to buffer where values will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_indices</td><td>List of initial indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_indices</td><td>List of final indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac79a05181b3eee1031e27cfc0d2c145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac79a05181b3eee1031e27cfc0d2c145">&#9670;&nbsp;</a></span>add_to_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::add_to_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically add to the value of one var element. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall between the values returned by <a class="el" href="classyask_1_1yk__var.html#aaf5b3f06b832bbf77b8f722fda8a2998" title="Get the first valid index in this rank in the specified dimension.">get_first_local_index()</a> and <a class="el" href="classyask_1_1yk__var.html#a7266bb36c93cb6ae538a0f081f22fad7" title="Get the last index in this rank in the specified dimension.">get_last_local_index()</a>, inclusive. Updates are OpenMP atomic, meaning that this function can be called by several OpenMP threads without causing a race condition. If storage has not been allocated for this var, this will have no effect and return zero (0) if <code>strict_indices</code> is <code>false</code>, or it will throw an exception if <code>strict_indices</code> is <code>true</code>. </p><dl class="section note"><dt>Note</dt><dd>The parameter value is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution::get_element_bytes()</a> returns 4. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements updated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>This value will be added to element in var. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf4832584daca2f5139b8a8ba93bcf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4832584daca2f5139b8a8ba93bcf6a">&#9670;&nbsp;</a></span>add_to_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::add_to_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically add to the value of one var element. </p>
<p>See <a class="el" href="classyask_1_1yk__var.html#aac79a05181b3eee1031e27cfc0d2c145" title="Atomically add to the value of one var element.">add_to_element()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>This value will be added to element in var. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cbfa0153ac69dfadf0e655246ddeac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbfa0153ac69dfadf0e655246ddeac2">&#9670;&nbsp;</a></span>set_all_elements_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_all_elements_same </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all var elements to the same value. </p>
<p>Sets all allocated elements, including those in the domain and padding area to the same specified value. If storage has not been allocated, this will have no effect. </p><dl class="section note"><dt>Note</dt><dd>The parameter is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution::get_element_bytes()</a> returns 4. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>All elements will be set to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad919afb54bbde78938a3939e76df0cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad919afb54bbde78938a3939e76df0cd8">&#9670;&nbsp;</a></span>set_elements_in_slice_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::set_elements_in_slice_same </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>first_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>last_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize var elements within specified subset of the var to the same value. </p>
<p>Sets all elements from <code>first_indices</code> to <code>last_indices</code> in each dimension to the specified value. Provide indices in two lists in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall between the values returned by <a class="el" href="classyask_1_1yk__var.html#aaf5b3f06b832bbf77b8f722fda8a2998" title="Get the first valid index in this rank in the specified dimension.">get_first_local_index()</a> and <a class="el" href="classyask_1_1yk__var.html#a7266bb36c93cb6ae538a0f081f22fad7" title="Get the last index in this rank in the specified dimension.">get_last_local_index()</a>, inclusive, if <code>strict_indices</code> is <code>true</code>. If storage has not been allocated for this var, this will have no effect and return zero (0) if <code>strict_indices</code> is <code>false</code>, or it will throw an exception if <code>strict_indices</code> is <code>true</code>. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>All elements in the slice will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_indices</td><td>List of initial indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_indices</td><td>List of final indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, only elements within the allocation of this var will be set, and elements outside will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56798ab60559bd84fdc204d7255ebe46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56798ab60559bd84fdc204d7255ebe46">&#9670;&nbsp;</a></span>set_elements_in_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::set_elements_in_slice </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>first_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>last_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set var elements within specified subset of the var from values in a buffer. </p>
<p>Reads elements from consecutive memory locations, starting at <code>buffer_ptr</code> and writes them from <code>first_indices</code> to <code>last_indices</code> in each dimension. Indices in the buffer progress in row-major order. The buffer pointed to must contain either 4 or 8 byte FP values per element in the subset, depending on the FP precision of the solution. The buffer pointed to must contain the number of FP values in the specified slice, where each FP value is the size of <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution::get_element_bytes()</a>. Since the writes proceed in row-major order, the last index is "unit-stride" in the buffer. Provide indices in two lists in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall between the values returned by <a class="el" href="classyask_1_1yk__var.html#aaf5b3f06b832bbf77b8f722fda8a2998" title="Get the first valid index in this rank in the specified dimension.">get_first_local_index()</a> and <a class="el" href="classyask_1_1yk__var.html#a7266bb36c93cb6ae538a0f081f22fad7" title="Get the last index in this rank in the specified dimension.">get_last_local_index()</a>, inclusive. If storage has not been allocated for this var, this will throw an exception. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements written. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_ptr</td><td>Pointer to buffer where values will be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_indices</td><td>List of initial indices, one for each var dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_indices</td><td>List of final indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55d6c585b8384881065c01bb067c96dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d6c585b8384881065c01bb067c96dd">&#9670;&nbsp;</a></span>format_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_var::format_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yask.html#gab23959584aacc15a84d1eca058036d09">idx_t_vec</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the indices for human-readable display. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__var.html#adf2e93317a2e86d80713ad56a46fdc68" title="Get all the dimensions in this var.">get_dim_names()</a>. </p><dl class="section return"><dt>Returns</dt><dd>A string containing the var name and the index values. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae929dea5359d07e7541abab78ca7b139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae929dea5359d07e7541abab78ca7b139">&#9670;&nbsp;</a></span>format_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_var::format_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yask.html#ga9a86862ece2cddc8fb77fac850c44161">idx_t_init_list</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the indices for human-readable display. </p>
<p>See <a class="el" href="classyask_1_1yk__var.html#a55d6c585b8384881065c01bb067c96dd" title="Format the indices for human-readable display.">format_indices()</a>. </p><dl class="section return"><dt>Returns</dt><dd>A string containing the var name and the index values. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each var dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2de3a290dae76a40b3c208074ebbdb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de3a290dae76a40b3c208074ebbdb89">&#9670;&nbsp;</a></span>get_halo_exchange_l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_var::get_halo_exchange_l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the maximum L1-norm of a neighbor rank for halo exchange. </p>
<p>This setting determines which MPI neighbors participate in a halo exchange. The L1-norm is also known as the "Manhattan distance" or "taxicab norm". In this case, the distance in <em>each</em> domain dimension can be only zero or one, so the sum can range from zero to the number of domain dimensions.</p>
<p>Examples for a domain size with 2 spatial dimensions (e.g., "x" and "y"): L1-norm = 0: no halos are exchanged for this var. L1-norm = 1: halos are exchanged between "up", "down", "left" and "right" neighbors. L1-norm = 2: halos are exchanged as above plus diagonal neighbors.</p>
<p>The actual exchanges are further controlled by the size of the halo in each direction per get_halo_size().</p>
<dl class="section return"><dt>Returns</dt><dd>L1-norm, ranging from zero to number of domain dimensions. </dd></dl>

</div>
</div>
<a id="a5f65d5983b3e8f16bb20c466d6b7f027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f65d5983b3e8f16bb20c466d6b7f027">&#9670;&nbsp;</a></span>set_halo_exchange_l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_halo_exchange_l1_norm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the maximum L1-norm of a neighbor rank for halo exchange. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classyask_1_1yk__var.html#a2de3a290dae76a40b3c208074ebbdb89" title="[Advanced] Get the maximum L1-norm of a neighbor rank for halo exchange.">get_halo_exchange_l1_norm()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>Maximum L1-norm of neighbor rank with which to exchange halos. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c4783735b2f5b72c659f1572c44598f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4783735b2f5b72c659f1572c44598f">&#9670;&nbsp;</a></span>is_dynamic_step_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::is_dynamic_step_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get whether the allocation of the step dimension of this var can be modified at run-time. </p>
<p>See <a class="el" href="classyask_1_1yk__var.html#a7bc339345cc04bb349e2f6bf586a29f1" title="[Advanced] Set the number of elements to allocate in the specified dimension.">set_alloc_size()</a>. </p>

</div>
</div>
<a id="ac68f7d6f9bbe826eed31e6dc2be01de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68f7d6f9bbe826eed31e6dc2be01de4">&#9670;&nbsp;</a></span>set_numa_preferred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::set_numa_preferred </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numa_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data. </p>
<p>This value is used when allocating data for this var. Thus, the desired NUMA policy must be set before calling alloc_data() or <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if NUMA preference was set; <code>false</code> if NUMA preferences are not enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numa_node</td><td>Preferred NUMA node. See <a class="el" href="classyask_1_1yk__solution.html#ac8bde8dfc73219cec84ad3033faabb90" title="[Advanced] Set the default preferred NUMA node on which to allocate data.">yk_solution::set_default_numa_preferred()</a> for other options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a052f304a6ac220ab43fc118172d33428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052f304a6ac220ab43fc118172d33428">&#9670;&nbsp;</a></span>get_numa_preferred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_var::get_numa_preferred </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of preferred NUMA node for this var. </dd></dl>

</div>
</div>
<a id="a370adca271068bd8952bbe9d1696a78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370adca271068bd8952bbe9d1696a78a">&#9670;&nbsp;</a></span>set_left_min_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_left_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum left padding in the specified dimension. </p>
<p>This sets the minimum number of elements in this var in the left padding area. This padding area can be used for required halo areas. This function may be useful in the unusual case where the final halo size is unknown when the storage is allocated.</p>
<p>Call <a class="el" href="classyask_1_1yk__var.html#a2a6b515ee0073b8ff35fb8bee47de00e" title="Get the actual left padding in the specified dimension.">get_left_pad_size()</a> to determine the actual padding size for the var. See additional behavior related to setting pad size under <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of padding for all vars.">yk_solution::set_min_pad_size()</a>. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a> for information on var sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Minimum number of elements to allocate before the domain size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02ee27a0c922e55def701d6efffc725c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ee27a0c922e55def701d6efffc725c">&#9670;&nbsp;</a></span>set_right_min_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_right_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum right padding in the specified dimension. </p>
<p>This sets the minimum number of elements in this var in the right padding area. This padding area can be used for required halo areas. This function may be useful in the unusual case where the final halo size is unknown when the storage is allocated.</p>
<p>Call <a class="el" href="classyask_1_1yk__var.html#a44d13a6f6925574545bd5594cecece43" title="Get the actual right padding in the specified dimension.">get_right_pad_size()</a> to determine the actual padding size for the var. See additional behavior related to setting pad size under <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of padding for all vars.">yk_solution::set_min_pad_size()</a>. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a> for information on var sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Minimum number of elements to allocate after the domain size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16aad88dc481991cbe83da7a55cb3799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16aad88dc481991cbe83da7a55cb3799">&#9670;&nbsp;</a></span>set_min_pad_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum padding in the specified dimension. </p>
<p>Shorthand for calling <a class="el" href="classyask_1_1yk__var.html#a370adca271068bd8952bbe9d1696a78a" title="[Advanced] Set the minimum left padding in the specified dimension.">set_left_min_pad_size()</a> and <a class="el" href="classyask_1_1yk__var.html#a02ee27a0c922e55def701d6efffc725c" title="[Advanced] Set the minimum right padding in the specified dimension.">set_right_min_pad_size()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Minimum number of elements to allocate before and after the domain size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89147504cd60e15520e1fa96c2ad5b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89147504cd60e15520e1fa96c2ad5b76">&#9670;&nbsp;</a></span>set_left_halo_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_left_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the left halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler, but this function allows you to override that value. If the left halo is set to a value larger than the left padding size, the left padding size will be automatically increase to accommodate it. </p><dl class="section note"><dt>Note</dt><dd>After data storage has been allocated, the left halo size can only be set to a value less than or equal to the left padding size in the given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements in the left halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d43cc66c47eb773c0e8aa043ec76099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d43cc66c47eb773c0e8aa043ec76099">&#9670;&nbsp;</a></span>set_right_halo_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_right_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the right halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler, but this function allows you to override that value. If the right halo is set to a value larger than the right padding size, the right padding size will be automatically increase to accommodate it. </p><dl class="section note"><dt>Note</dt><dd>After data storage has been allocated, the right halo size can only be set to a value less than or equal to the right padding size in the given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements in the right halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a722269d4ddc542181858eec462afd38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722269d4ddc542181858eec462afd38f">&#9670;&nbsp;</a></span>set_halo_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the left and right halo sizes in the specified dimension. </p>
<p>Alias for set_left_halo_size(dim, size); set_right_halo_size(dim, size). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements in the halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bc339345cc04bb349e2f6bf586a29f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc339345cc04bb349e2f6bf586a29f1">&#9670;&nbsp;</a></span>set_alloc_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_alloc_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the number of elements to allocate in the specified dimension. </p>
<p>Setting an allocation is only allowed in the following cases. Vars created via <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a> are defined at YASK compile time, and vars created via <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> methods are defined at YASK kernel run time.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Var creation time  </th><th class="markdownTableHeadNone">Var creation method  </th><th class="markdownTableHeadNone">Step dim  </th><th class="markdownTableHeadNone">Domain dim  </th><th class="markdownTableHeadNone">Misc dim   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Compile-time  </td><td class="markdownTableBodyNone"><a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a> + <a class="el" href="classyask_1_1yc__var.html#a528a6e79000ffc8addefd7519cc58ad6" title="[Advanced] Set whether the allocation of the step dimension of this var can be modified at run-time.">yc_var::set_dynamic_step_alloc</a> (false) [1]  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Yes [2]   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Compile-time  </td><td class="markdownTableBodyNone"><a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a> + <a class="el" href="classyask_1_1yc__var.html#a528a6e79000ffc8addefd7519cc58ad6" title="[Advanced] Set whether the allocation of the step dimension of this var can be modified at run-time.">yc_var::set_dynamic_step_alloc</a> (true) [1]  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Yes [2]   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Run-time  </td><td class="markdownTableBodyNone"><a class="el" href="classyask_1_1yk__solution.html#a75ba824977414468dd23f0a1d5f9eaf3" title="[Advanced] Add a new var to the solution.">yk_solution::new_var()</a>  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Yes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Run-time  </td><td class="markdownTableBodyNone"><a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a> [3]  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>[1] By default, variables created via <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a> do <em>not</em> allow dynamic step allocation. </dd>
<dd>
[2] Misc dim allocations cannot be changed for compile-time vars if the YASK compiler was run with the "-interleave-misc" option. </dd>
<dd>
[3] The term "fixed" in <a class="el" href="classyask_1_1yk__solution.html#a2899b81d090c4a2f468ccc31adfa9d85" title="[Advanced] Add a new var to the solution with a specified size.">yk_solution::new_fixed_size_var()</a> means that the domain size will not change automatically when its solution domain size changes. It does not mean that the sizes cannot be changed via the APIs&ndash;quite the opposite.</dd></dl>
<p>The allocation size cannot be changed after data storage has been allocated for this var. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be a domain dimension or a misc dimension for user-created vars. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5beae21df987bf4a93bec2ebf8a423f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5beae21df987bf4a93bec2ebf8a423f6">&#9670;&nbsp;</a></span>set_first_misc_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::set_first_misc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the first index of a specified miscellaneous dimension. </p>
<p>Sets the first valid index in a non-step and non-domain dimension. After calling this function, the last valid index will be the first index as set by this function plus the allocation size set by <a class="el" href="classyask_1_1yk__var.html#a7bc339345cc04bb349e2f6bf586a29f1" title="[Advanced] Set the number of elements to allocate in the specified dimension.">set_alloc_size()</a> minus one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a4184ac69b5e5af07e8cfc0317d6bd759" title="Get all the miscellaneous dimension names.">yk_solution::get_misc_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>New value for first index. May be negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb7ed5c0f513ae7a5480a480f08165b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7ed5c0f513ae7a5480a480f08165b7">&#9670;&nbsp;</a></span>get_first_rank_alloc_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_first_rank_alloc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the first accessible index in this var in this rank in the specified domain dimension. </p>
<p>Equivalent to get_first_local_index(dim), where <code>dim</code> is a domain dimension. </p><dl class="section return"><dt>Returns</dt><dd>First valid index in this var. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2919bd783fb240a9d0f43a866bf7f551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2919bd783fb240a9d0f43a866bf7f551">&#9670;&nbsp;</a></span>get_last_rank_alloc_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_last_rank_alloc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the last accessible index in this var in this rank in the specified domain dimension. </p>
<p>Equivalent to get_last_local_index(dim), where <code>dim</code> is a domain dimension. </p><dl class="section return"><dt>Returns</dt><dd>Last valid index in this var. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a24c2619b5f0471bcfe8eeb5aed769fec" title="Get all the domain dimension names.">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b09855a3cfa7e43c32fc43a24503340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b09855a3cfa7e43c32fc43a24503340">&#9670;&nbsp;</a></span>is_storage_allocated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::is_storage_allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine whether storage has been allocated. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if storage has been allocated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4741fd9f7413d5ad634c755a52ffc6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4741fd9f7413d5ad634c755a52ffc6b3">&#9670;&nbsp;</a></span>get_num_storage_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_num_storage_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine size of raw storage in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum number of bytes required for storage given the current domain size and padding settings. </dd></dl>

</div>
</div>
<a id="a73864906531e75762a4d0829b65cd997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73864906531e75762a4d0829b65cd997">&#9670;&nbsp;</a></span>get_num_storage_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> yask::yk_var::get_num_storage_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine size of raw storage in elements. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyask_1_1yk__var.html#a4741fd9f7413d5ad634c755a52ffc6b3" title="[Advanced] Determine size of raw storage in bytes.">get_num_storage_bytes()</a> / <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution.get_element_bytes()</a>. </dd></dl>

</div>
</div>
<a id="aa3b479a98b425c3a8d504145972198e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b479a98b425c3a8d504145972198e0">&#9670;&nbsp;</a></span>alloc_storage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::alloc_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Explicitly allocate data-storage memory for this var. </p>
<p>Amount of allocation is calculated based on domain, padding, and step-dimension allocation sizes. Any pre-existing storage will be released before allocation as via <a class="el" href="classyask_1_1yk__var.html#a9e3a6024af940112404ad871dab63cdb" title="[Advanced] Explicitly release any allocated data-storage for this var.">release_storage()</a>. See allocation options in the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a>. </p>

</div>
</div>
<a id="a9e3a6024af940112404ad871dab63cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3a6024af940112404ad871dab63cdb">&#9670;&nbsp;</a></span>release_storage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::release_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Explicitly release any allocated data-storage for this var. </p>
<p>This will release storage allocated via any of the options described in the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a>. </p>

</div>
</div>
<a id="a3611ad6d130cb5ee7e030e6ad0c24f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3611ad6d130cb5ee7e030e6ad0c24f5b">&#9670;&nbsp;</a></span>is_storage_layout_identical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_var::is_storage_layout_identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determines whether storage layout is the same as another var. </p>
<p>In order for the storage layout to be identical, the following must be the same:</p><ul>
<li>Number of dimensions.</li>
<li>Name of each dimension, in the same order.</li>
<li>Vector folding in each dimension.</li>
<li>Allocation size in each dimension.</li>
<li>Rank (local) domain size in each domain dimension.</li>
<li>Padding size in each domain dimension.</li>
</ul>
<p>The following do not have to be identical:</p><ul>
<li>Halo size.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if storage for this var has the same layout as <code>other</code> or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa095607d5493fcba38cb332053155b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa095607d5493fcba38cb332053155b7f">&#9670;&nbsp;</a></span>fuse_vars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_var::fuse_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yk.html#ga95f75e2b515e5455b570ae705115696a">yk_var_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Merge this var with another var. </p>
<p>After calling this API, this var var will effectively become another reference to the <code>source</code> var. Any subsequent API applied to this var or the <code>source</code> var will access the same data and/or effect the same changes.</p>
<p>Storage implications:</p><ul>
<li>Any pre-existing storage in this var will be released.</li>
<li>The storage of the this var will become allocated or unallocated depending on that of the source var.</li>
<li>After fusing, calling <a class="el" href="classyask_1_1yk__var.html#a9e3a6024af940112404ad871dab63cdb" title="[Advanced] Explicitly release any allocated data-storage for this var.">release_storage()</a> on this var or the <code>source</code> var will apply to both.</li>
</ul>
<p>To ensure that the kernels created by the YASK compiler work properly, if this var is used in a kernel, the dimensions and fold-lengths of the <code>source</code> var must be identical or an exception will the thrown. If the <code>source</code> var is a fixed-size var, the storage, local domain sizes, halos, etc. of the var must be set to be compatible with the solution before calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>. Otherwise, <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a> will throw an exception.</p>
<p>See allocation options and more information about var sizes in the "Detailed Description" for <a class="el" href="classyask_1_1yk__var.html">yk_var</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Var to be merged with this var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a4e42c4cfc5b3b6a5d998611d0d8602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4e42c4cfc5b3b6a5d998611d0d8602">&#9670;&nbsp;</a></span>get_raw_storage_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* yask::yk_var::get_raw_storage_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get pointer to raw data storage buffer. </p>
<p>The following assumptions about the contents of data are safe:</p><ul>
<li>Each FP element starts at a number of bytes from the beginning of the buffer which is a multiple of <a class="el" href="classyask_1_1yk__solution.html#a50e565487b7175447cc9f6489221eef4" title="Get the floating-point precision size.">yk_solution::get_element_bytes()</a>.</li>
<li>All the FP elements will be located within <a class="el" href="classyask_1_1yk__var.html#a4741fd9f7413d5ad634c755a52ffc6b3" title="[Advanced] Determine size of raw storage in bytes.">get_num_storage_bytes()</a> bytes from the beginning of the buffer.</li>
<li>A call to <a class="el" href="classyask_1_1yk__var.html#a0cbfa0153ac69dfadf0e655246ddeac2" title="Initialize all var elements to the same value.">set_all_elements_same()</a> will initialize all elements within <a class="el" href="classyask_1_1yk__var.html#a4741fd9f7413d5ad634c755a52ffc6b3" title="[Advanced] Determine size of raw storage in bytes.">get_num_storage_bytes()</a> bytes from the beginning of the buffer.</li>
<li>If <a class="el" href="classyask_1_1yk__var.html#a3611ad6d130cb5ee7e030e6ad0c24f5b" title="[Advanced] Determines whether storage layout is the same as another var.">is_storage_layout_identical()</a> returns <code>true</code> between this and some other var, any given element index applied to both vars will refer to an element at the same offset into their respective data buffers.</li>
</ul>
<p>Thus,</p><ul>
<li>You can perform element-wise unary mathematical operations on all elements of a var via its raw buffer, e.g., add some constant value to all elements.</li>
<li>If the layouts of two vars are identical, you can use their raw buffers to copy all data from one to the other or perform element-wise binary mathematical operations on them, e.g., add all elements from one var to another.</li>
</ul>
<p>The following assumptions are not safe:</p><ul>
<li>Any expectations regarding the relationship between an element index and that element's offset from the beginning of the buffer such as row-major or column-major layout.</li>
<li>All elements in the buffer are part of the rank domain or halo.</li>
<li>All elements in the buffer contain valid floating-point values.</li>
</ul>
<p>Thus,</p><ul>
<li>You should not perform any operations dependent on the logical indices of any element via raw buffer, e.g., matrix multiply.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Pointer to raw data storage if <a class="el" href="classyask_1_1yk__var.html#a3b09855a3cfa7e43c32fc43a24503340" title="[Advanced] Determine whether storage has been allocated.">is_storage_allocated()</a> returns <code>true</code> or NULL otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="yk__var__api_8hpp_source.html">yk_var_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
