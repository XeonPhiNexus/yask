<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YASK: yask::yc_solution Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kit: a software framework for creating HPC stencil code. Copyright 2014-2019 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yask</b></li><li class="navelem"><a class="el" href="classyask_1_1yc__solution.html">yc_solution</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyask_1_1yc__solution-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">yask::yc_solution Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__yc.html">YASK Compiler</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Stencil solution.  
 <a href="classyask_1_1yc__solution.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="yask__compiler__api_8hpp_source.html">yask_compiler_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad24c46b2a6d40b0c2af867157dcea826"><td class="memItemLeft" align="right" valign="top"><a id="ad24c46b2a6d40b0c2af867157dcea826" name="ad24c46b2a6d40b0c2af867157dcea826"></a>
typedef std::function&lt; void(<a class="el" href="classyask_1_1yc__solution.html">yc_solution</a> &amp;soln, <a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> output)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>output_hook_t</b></td></tr>
<tr class="memdesc:ad24c46b2a6d40b0c2af867157dcea826"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Callback type for <a class="el" href="classyask_1_1yc__solution.html#aa669130ec18bcf1fa9a5090aa6b510d7" title="[Advanced] Register a function to be called before a solution is output.">call_before_output()</a>. <br /></td></tr>
<tr class="separator:ad24c46b2a6d40b0c2af867157dcea826"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff540803d358a5dcd304f09c522ec867"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#aff540803d358a5dcd304f09c522ec867">set_debug_output</a> (<a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> debug)=0</td></tr>
<tr class="memdesc:aff540803d358a5dcd304f09c522ec867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set object to receive debug output.  <br /></td></tr>
<tr class="separator:aff540803d358a5dcd304f09c522ec867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ebb8dc2bff24f15b5a56e46efc9f8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a630ebb8dc2bff24f15b5a56e46efc9f8">get_name</a> () const =0</td></tr>
<tr class="memdesc:a630ebb8dc2bff24f15b5a56e46efc9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the solution.  <br /></td></tr>
<tr class="separator:a630ebb8dc2bff24f15b5a56e46efc9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfefccda72a3560e6664471a9ab451a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a1dfefccda72a3560e6664471a9ab451a">set_name</a> (std::string name)=0</td></tr>
<tr class="memdesc:a1dfefccda72a3560e6664471a9ab451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the solution.  <br /></td></tr>
<tr class="separator:a1dfefccda72a3560e6664471a9ab451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113e505343c5f2598811669f767930c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a8113e505343c5f2598811669f767930c">get_description</a> () const =0</td></tr>
<tr class="memdesc:a8113e505343c5f2598811669f767930c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of the solution.  <br /></td></tr>
<tr class="separator:a8113e505343c5f2598811669f767930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc13f5daf402805f9b1f66996d9d6d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a3cc13f5daf402805f9b1f66996d9d6d3">set_description</a> (std::string description)=0</td></tr>
<tr class="memdesc:a3cc13f5daf402805f9b1f66996d9d6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the description of the solution.  <br /></td></tr>
<tr class="separator:a3cc13f5daf402805f9b1f66996d9d6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d444584538c565e9bf618a311ade6f"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ab7d444584538c565e9bf618a311ade6f">get_target</a> ()=0</td></tr>
<tr class="memdesc:ab7d444584538c565e9bf618a311ade6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current output-file format.  <br /></td></tr>
<tr class="separator:ab7d444584538c565e9bf618a311ade6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c03fc69e306a700de8c5ae3973229c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a1c03fc69e306a700de8c5ae3973229c2">set_target</a> (const std::string &amp;<a class="el" href="classyask_1_1yc__solution.html#a5f3624ded964c465724fd0221d5a2aaa">format</a>)=0</td></tr>
<tr class="memdesc:a1c03fc69e306a700de8c5ae3973229c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output target.  <br /></td></tr>
<tr class="separator:a1c03fc69e306a700de8c5ae3973229c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc13ff80f75eac42bb7300c24246f78c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#abc13ff80f75eac42bb7300c24246f78c">is_target_set</a> ()=0</td></tr>
<tr class="memdesc:abc13ff80f75eac42bb7300c24246f78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether target has been set.  <br /></td></tr>
<tr class="separator:abc13ff80f75eac42bb7300c24246f78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78551a2f7ca0a9644fa802d0806b7642"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a78551a2f7ca0a9644fa802d0806b7642">get_element_bytes</a> () const =0</td></tr>
<tr class="memdesc:a78551a2f7ca0a9644fa802d0806b7642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current floating-point precision setting.  <br /></td></tr>
<tr class="separator:a78551a2f7ca0a9644fa802d0806b7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce565febd97f50efae59c37d7d5ef4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a6ce565febd97f50efae59c37d7d5ef4f">set_element_bytes</a> (int nbytes)=0</td></tr>
<tr class="memdesc:a6ce565febd97f50efae59c37d7d5ef4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set floating-point precision.  <br /></td></tr>
<tr class="separator:a6ce565febd97f50efae59c37d7d5ef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b0f12d3943483514e16c82c15a42b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b">new_var</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:a192b0f12d3943483514e16c82c15a42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional variable in the solution.  <br /></td></tr>
<tr class="separator:a192b0f12d3943483514e16c82c15a42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daa8ae2e61c612cdb79241e43b34fcc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a4daa8ae2e61c612cdb79241e43b34fcc">new_var</a> (const std::string &amp;name, const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:a4daa8ae2e61c612cdb79241e43b34fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional variable in the solution.  <br /></td></tr>
<tr class="separator:a4daa8ae2e61c612cdb79241e43b34fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac025854d8d7a0e4c62753dda67ff9e39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ac025854d8d7a0e4c62753dda67ff9e39">new_scratch_var</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:ac025854d8d7a0e4c62753dda67ff9e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional scratch variable in the solution.  <br /></td></tr>
<tr class="separator:ac025854d8d7a0e4c62753dda67ff9e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f1bd432ae6b977d8a150e319856228"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#aa3f1bd432ae6b977d8a150e319856228">new_scratch_var</a> (const std::string &amp;name, const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:aa3f1bd432ae6b977d8a150e319856228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional scratch variable in the solution.  <br /></td></tr>
<tr class="separator:aa3f1bd432ae6b977d8a150e319856228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49cc384ea0686e075885fdd79a0bae9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ab49cc384ea0686e075885fdd79a0bae9">get_num_vars</a> () const =0</td></tr>
<tr class="memdesc:ab49cc384ea0686e075885fdd79a0bae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vars in the solution.  <br /></td></tr>
<tr class="separator:ab49cc384ea0686e075885fdd79a0bae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a126f887a0c6b206844fc84bcc4c9e0"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a3a126f887a0c6b206844fc84bcc4c9e0">get_vars</a> ()=0</td></tr>
<tr class="memdesc:a3a126f887a0c6b206844fc84bcc4c9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vars in the solution.  <br /></td></tr>
<tr class="separator:a3a126f887a0c6b206844fc84bcc4c9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6711eac1757a98387c4a90b9f7802c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a8c6711eac1757a98387c4a90b9f7802c">get_var</a> (const std::string &amp;name)=0</td></tr>
<tr class="memdesc:a8c6711eac1757a98387c4a90b9f7802c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified var.  <br /></td></tr>
<tr class="separator:a8c6711eac1757a98387c4a90b9f7802c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1168b5b8044e39c047d81a5fe5efc06e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a1168b5b8044e39c047d81a5fe5efc06e">set_fold_len</a> (const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> dim, int len)=0</td></tr>
<tr class="memdesc:a1168b5b8044e39c047d81a5fe5efc06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vectorization length in given dimension.  <br /></td></tr>
<tr class="separator:a1168b5b8044e39c047d81a5fe5efc06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaefa9675e9551ec10b9eee0016a0822"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#abaefa9675e9551ec10b9eee0016a0822">is_folding_set</a> ()=0</td></tr>
<tr class="memdesc:abaefa9675e9551ec10b9eee0016a0822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether any folding has been set.  <br /></td></tr>
<tr class="separator:abaefa9675e9551ec10b9eee0016a0822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf489e67ed8cc753e999b1495dd4dde"><td class="memItemLeft" align="right" valign="top"><a id="afaf489e67ed8cc753e999b1495dd4dde" name="afaf489e67ed8cc753e999b1495dd4dde"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_folding</b> ()=0</td></tr>
<tr class="memdesc:afaf489e67ed8cc753e999b1495dd4dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vector-folding settings. <br /></td></tr>
<tr class="separator:afaf489e67ed8cc753e999b1495dd4dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb1df4af6886e82f98904473873272"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a45cb1df4af6886e82f98904473873272">set_cluster_mult</a> (const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> dim, int mult)=0</td></tr>
<tr class="memdesc:a45cb1df4af6886e82f98904473873272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cluster multiplier (unroll factor) in given dimension.  <br /></td></tr>
<tr class="separator:a45cb1df4af6886e82f98904473873272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8927aebccf305d7224d6bc3dafb8f263"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a8927aebccf305d7224d6bc3dafb8f263">is_clustering_set</a> ()=0</td></tr>
<tr class="memdesc:a8927aebccf305d7224d6bc3dafb8f263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether any clustering has been set.  <br /></td></tr>
<tr class="separator:a8927aebccf305d7224d6bc3dafb8f263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ddf5e4155d64cea2b39d5cb1e2435e"><td class="memItemLeft" align="right" valign="top"><a id="ac4ddf5e4155d64cea2b39d5cb1e2435e" name="ac4ddf5e4155d64cea2b39d5cb1e2435e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_clustering</b> ()=0</td></tr>
<tr class="memdesc:ac4ddf5e4155d64cea2b39d5cb1e2435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vector-clustering settings. <br /></td></tr>
<tr class="separator:ac4ddf5e4155d64cea2b39d5cb1e2435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0d2dad6b123d0a1444e2f2a74d1ad4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a2c0d2dad6b123d0a1444e2f2a74d1ad4">get_num_equations</a> () const =0</td></tr>
<tr class="memdesc:a2c0d2dad6b123d0a1444e2f2a74d1ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of equations in the solution.  <br /></td></tr>
<tr class="separator:a2c0d2dad6b123d0a1444e2f2a74d1ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b08588481e1fd41bc8d6ae74743a88"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a96b08588481e1fd41bc8d6ae74743a88">get_equations</a> ()=0</td></tr>
<tr class="memdesc:a96b08588481e1fd41bc8d6ae74743a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the defined equations.  <br /></td></tr>
<tr class="separator:a96b08588481e1fd41bc8d6ae74743a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe595d131a70b3ef881e4e2ab35b47d6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#abe595d131a70b3ef881e4e2ab35b47d6">get_prefetch_dist</a> (int level)=0</td></tr>
<tr class="memdesc:abe595d131a70b3ef881e4e2ab35b47d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current prefetch distance for the given cache.  <br /></td></tr>
<tr class="separator:abe595d131a70b3ef881e4e2ab35b47d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa849ba0ae1af7890d8f6f5c0b095ff25"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#aa849ba0ae1af7890d8f6f5c0b095ff25">set_prefetch_dist</a> (int level, int distance)=0</td></tr>
<tr class="memdesc:aa849ba0ae1af7890d8f6f5c0b095ff25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the prefetch distance for the given cache.  <br /></td></tr>
<tr class="separator:aa849ba0ae1af7890d8f6f5c0b095ff25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18b4c2eba024a830d5e43c83df958b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a9c18b4c2eba024a830d5e43c83df958b">output_solution</a> (<a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> output)=0</td></tr>
<tr class="memdesc:a9c18b4c2eba024a830d5e43c83df958b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize and the current equation(s) and write to given output object.  <br /></td></tr>
<tr class="separator:a9c18b4c2eba024a830d5e43c83df958b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa669130ec18bcf1fa9a5090aa6b510d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#aa669130ec18bcf1fa9a5090aa6b510d7">call_before_output</a> (<a class="el" href="classyask_1_1yc__solution.html#ad24c46b2a6d40b0c2af867157dcea826">output_hook_t</a> hook_fn)=0</td></tr>
<tr class="memdesc:aa669130ec18bcf1fa9a5090aa6b510d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Register a function to be called before a solution is output.  <br /></td></tr>
<tr class="separator:aa669130ec18bcf1fa9a5090aa6b510d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c837c7eca24ad461fb977c48f4237ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a7c837c7eca24ad461fb977c48f4237ce">call_after_new_solution</a> (const std::string &amp;code)=0</td></tr>
<tr class="memdesc:a7c837c7eca24ad461fb977c48f4237ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add block of custom C++ code to the kernel solution.  <br /></td></tr>
<tr class="separator:a7c837c7eca24ad461fb977c48f4237ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc810afcb4ef91c10aa5e0e7092476f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a3dc810afcb4ef91c10aa5e0e7092476f">set_domain_dims</a> (const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:a3dc810afcb4ef91c10aa5e0e7092476f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Explicitly define and order the domain dimensions used in the solution.  <br /></td></tr>
<tr class="separator:a3dc810afcb4ef91c10aa5e0e7092476f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab798850bc3a6bf88322a2f39765ee831"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ab798850bc3a6bf88322a2f39765ee831">set_domain_dims</a> (const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:ab798850bc3a6bf88322a2f39765ee831"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Explicitly define and order the domain dimensions used in the solution.  <br /></td></tr>
<tr class="separator:ab798850bc3a6bf88322a2f39765ee831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad234ecd4964bcb57b1876be87baf57bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ad234ecd4964bcb57b1876be87baf57bd">set_step_dim</a> (const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> dim)=0</td></tr>
<tr class="memdesc:ad234ecd4964bcb57b1876be87baf57bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Explicitly identify the step dimension in the solution.  <br /></td></tr>
<tr class="separator:ad234ecd4964bcb57b1876be87baf57bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac181c24ab7af945318a055cef3b52ee6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ac181c24ab7af945318a055cef3b52ee6">set_dependency_checker_enabled</a> (bool enable)=0</td></tr>
<tr class="memdesc:ac181c24ab7af945318a055cef3b52ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Enable or disable automatic dependency checker.  <br /></td></tr>
<tr class="separator:ac181c24ab7af945318a055cef3b52ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4a7ac8cc9e6be09b115a106bac769b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a8b4a7ac8cc9e6be09b115a106bac769b">is_dependency_checker_enabled</a> () const =0</td></tr>
<tr class="memdesc:a8b4a7ac8cc9e6be09b115a106bac769b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine whether automatic dependency checker is enabled.  <br /></td></tr>
<tr class="separator:a8b4a7ac8cc9e6be09b115a106bac769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727a91bb87e42de9822ac6540e3fc93e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a727a91bb87e42de9822ac6540e3fc93e">add_flow_dependency</a> (<a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> from, <a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> to)=0</td></tr>
<tr class="memdesc:a727a91bb87e42de9822ac6540e3fc93e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a dependency between two equations.  <br /></td></tr>
<tr class="separator:a727a91bb87e42de9822ac6540e3fc93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd08d7a26c93d5073134f3b76dcc38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a42cd08d7a26c93d5073134f3b76dcc38">clear_dependencies</a> ()=0</td></tr>
<tr class="memdesc:a42cd08d7a26c93d5073134f3b76dcc38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Remove all existing dependencies.  <br /></td></tr>
<tr class="separator:a42cd08d7a26c93d5073134f3b76dcc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3624ded964c465724fd0221d5a2aaa"><td class="memItemLeft" align="right" valign="top"><a id="a5f3624ded964c465724fd0221d5a2aaa" name="a5f3624ded964c465724fd0221d5a2aaa"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>format</b> (const std::string &amp;format_type, <a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> output)</td></tr>
<tr class="memdesc:a5f3624ded964c465724fd0221d5a2aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#a1c03fc69e306a700de8c5ae3973229c2" title="Set the output target.">set_target()</a> and <a class="el" href="classyask_1_1yc__solution.html#a9c18b4c2eba024a830d5e43c83df958b" title="Optimize and the current equation(s) and write to given output object.">output_solution()</a>. <br /></td></tr>
<tr class="separator:a5f3624ded964c465724fd0221d5a2aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a140813b38f5128b730c2831db9fb4"><td class="memItemLeft" align="right" valign="top"><a id="a99a140813b38f5128b730c2831db9fb4" name="a99a140813b38f5128b730c2831db9fb4"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>new_grid</b> (const std::string &amp;name, const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a99a140813b38f5128b730c2831db9fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">new_var()</a>. <br /></td></tr>
<tr class="separator:a99a140813b38f5128b730c2831db9fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233eccb68505d3900b1199493fc74796"><td class="memItemLeft" align="right" valign="top"><a id="a233eccb68505d3900b1199493fc74796" name="a233eccb68505d3900b1199493fc74796"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>new_grid</b> (const std::string &amp;name, const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a233eccb68505d3900b1199493fc74796"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">new_var()</a>. <br /></td></tr>
<tr class="separator:a233eccb68505d3900b1199493fc74796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e30883d0a97aa0ef5af6832f67bd863"><td class="memItemLeft" align="right" valign="top"><a id="a9e30883d0a97aa0ef5af6832f67bd863" name="a9e30883d0a97aa0ef5af6832f67bd863"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>new_scratch_grid</b> (const std::string &amp;name, const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a9e30883d0a97aa0ef5af6832f67bd863"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#ac025854d8d7a0e4c62753dda67ff9e39" title="Create an n-dimensional scratch variable in the solution.">new_scratch_var()</a>. <br /></td></tr>
<tr class="separator:a9e30883d0a97aa0ef5af6832f67bd863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24afb1d88e355707c2113f749445329"><td class="memItemLeft" align="right" valign="top"><a id="ae24afb1d88e355707c2113f749445329" name="ae24afb1d88e355707c2113f749445329"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>new_scratch_grid</b> (const std::string &amp;name, const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:ae24afb1d88e355707c2113f749445329"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#ac025854d8d7a0e4c62753dda67ff9e39" title="Create an n-dimensional scratch variable in the solution.">new_scratch_var()</a>. <br /></td></tr>
<tr class="separator:ae24afb1d88e355707c2113f749445329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246a87a4165aa119cc3a0761afa4ffbf"><td class="memItemLeft" align="right" valign="top"><a id="a246a87a4165aa119cc3a0761afa4ffbf" name="a246a87a4165aa119cc3a0761afa4ffbf"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_grids</b> () const</td></tr>
<tr class="memdesc:a246a87a4165aa119cc3a0761afa4ffbf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#ab49cc384ea0686e075885fdd79a0bae9" title="Get the number of vars in the solution.">get_num_vars()</a>. <br /></td></tr>
<tr class="separator:a246a87a4165aa119cc3a0761afa4ffbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efd4157303b45f834332ca34e761eb9"><td class="memItemLeft" align="right" valign="top"><a id="a0efd4157303b45f834332ca34e761eb9" name="a0efd4157303b45f834332ca34e761eb9"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> std::vector&lt; <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_grids</b> ()</td></tr>
<tr class="memdesc:a0efd4157303b45f834332ca34e761eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#a3a126f887a0c6b206844fc84bcc4c9e0" title="Get all the vars in the solution.">get_vars()</a>. <br /></td></tr>
<tr class="separator:a0efd4157303b45f834332ca34e761eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f63562fa2519ad4817c2698832c0dcb"><td class="memItemLeft" align="right" valign="top"><a id="a7f63562fa2519ad4817c2698832c0dcb" name="a7f63562fa2519ad4817c2698832c0dcb"></a>
<a class="el" href="yask__common__api_8hpp.html#af7d3d837169568cf38a2efc3e7b04123">YASK_DEPRECATED</a> <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_grid</b> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a7f63562fa2519ad4817c2698832c0dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Use <a class="el" href="classyask_1_1yc__solution.html#a8c6711eac1757a98387c4a90b9f7802c" title="Get the specified var.">get_var()</a>. <br /></td></tr>
<tr class="separator:a7f63562fa2519ad4817c2698832c0dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stencil solution. </p>
<p>Objects of this type contain all the vars and equations that comprise a solution. Must be created via <a class="el" href="classyask_1_1yc__factory.html#adce155773c9b0d469263303919681d69" title="Create a stencil solution.">yc_factory::new_solution()</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aff540803d358a5dcd304f09c522ec867" name="aff540803d358a5dcd304f09c522ec867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff540803d358a5dcd304f09c522ec867">&#9670;&#160;</a></span>set_debug_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_debug_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a>&#160;</td>
          <td class="paramname"><em>debug</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set object to receive debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">debug</td><td>Pointer to object to receive debug output. See <a class="el" href="classyask_1_1yask__output__factory.html">yask_output_factory</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a630ebb8dc2bff24f15b5a56e46efc9f8" name="a630ebb8dc2bff24f15b5a56e46efc9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ebb8dc2bff24f15b5a56e46efc9f8">&#9670;&#160;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yc_solution::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the solution name provided via new_solution() or <a class="el" href="classyask_1_1yc__solution.html#a1dfefccda72a3560e6664471a9ab451a" title="Set the name of the solution.">set_name()</a>. </dd></dl>

</div>
</div>
<a id="a1dfefccda72a3560e6664471a9ab451a" name="a1dfefccda72a3560e6664471a9ab451a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfefccda72a3560e6664471a9ab451a">&#9670;&#160;</a></span>set_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the name of the solution. </p>
<p>Allows changing the name from what was provided via new_solution(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name; must be a valid C++ identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8113e505343c5f2598811669f767930c" name="a8113e505343c5f2598811669f767930c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8113e505343c5f2598811669f767930c">&#9670;&#160;</a></span>get_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yc_solution::get_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the description of the solution. </p>
<p>See <a class="el" href="classyask_1_1yc__solution.html#a3cc13f5daf402805f9b1f66996d9d6d3" title="Set the description of the solution.">set_description()</a>. </p><dl class="section return"><dt>Returns</dt><dd>String containing the solution description. </dd></dl>

</div>
</div>
<a id="a3cc13f5daf402805f9b1f66996d9d6d3" name="a3cc13f5daf402805f9b1f66996d9d6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc13f5daf402805f9b1f66996d9d6d3">&#9670;&#160;</a></span>set_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_description </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the description of the solution. </p>
<p>By default, the solution description is the same as that provided via new_solution() or <a class="el" href="classyask_1_1yc__solution.html#a1dfefccda72a3560e6664471a9ab451a" title="Set the name of the solution.">set_name()</a>. This allows setting the description to any string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">description</td><td>Any descriptive phrase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7d444584538c565e9bf618a311ade6f" name="ab7d444584538c565e9bf618a311ade6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d444584538c565e9bf618a311ade6f">&#9670;&#160;</a></span>get_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yc_solution::get_target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current output-file format. </p>
<dl class="section return"><dt>Returns</dt><dd>Current target.</dd></dl>
<p>Throws an exception if the target hasn't been set via <a class="el" href="classyask_1_1yc__solution.html#a1c03fc69e306a700de8c5ae3973229c2" title="Set the output target.">set_target()</a>. </p>

</div>
</div>
<a id="a1c03fc69e306a700de8c5ae3973229c2" name="a1c03fc69e306a700de8c5ae3973229c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c03fc69e306a700de8c5ae3973229c2">&#9670;&#160;</a></span>set_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_target </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output target. </p>
<p>Currently supported targets: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Output    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">intel64   </td><td class="markdownTableBodyNone">YASK kernel for generic 64-bit C++.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">avx   </td><td class="markdownTableBodyNone">YASK kernel for CORE AVX ISA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">avx2   </td><td class="markdownTableBodyNone">YASK kernel for CORE AVX2 ISA.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">avx512   </td><td class="markdownTableBodyNone">YASK kernel for CORE AVX-512 ISA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">avx512-ymm   </td><td class="markdownTableBodyNone">YASK kernel for CORE AVX-512 ISA with 256-bit SIMD.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">knl   </td><td class="markdownTableBodyNone">YASK kernel for MIC AVX-512 ISA.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">knc   </td><td class="markdownTableBodyNone">YASK kernel for Knights Corner ISA.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dot   </td><td class="markdownTableBodyNone">DOT-language description.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dot-lite   </td><td class="markdownTableBodyNone">DOT-language description of var accesses only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pseudo   </td><td class="markdownTableBodyNone">Human-readable pseudo-code (for debug).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pseudo-long   </td><td class="markdownTableBodyNone">Human-readable pseudo-code with intermediate variables.   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Output-file format from above list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc13ff80f75eac42bb7300c24246f78c" name="abc13ff80f75eac42bb7300c24246f78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc13ff80f75eac42bb7300c24246f78c">&#9670;&#160;</a></span>is_target_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yc_solution::is_target_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether target has been set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classyask_1_1yc__solution.html#a1c03fc69e306a700de8c5ae3973229c2" title="Set the output target.">set_target()</a> has been called with a valid format; <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a78551a2f7ca0a9644fa802d0806b7642" name="a78551a2f7ca0a9644fa802d0806b7642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78551a2f7ca0a9644fa802d0806b7642">&#9670;&#160;</a></span>get_element_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yc_solution::get_element_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current floating-point precision setting. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in a FP number. </dd></dl>

</div>
</div>
<a id="a6ce565febd97f50efae59c37d7d5ef4f" name="a6ce565febd97f50efae59c37d7d5ef4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce565febd97f50efae59c37d7d5ef4f">&#9670;&#160;</a></span>set_element_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_element_bytes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set floating-point precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Number of bytes in a FP number. Should be 4 or 8. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a192b0f12d3943483514e16c82c15a42b" name="a192b0f12d3943483514e16c82c15a42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192b0f12d3943483514e16c82c15a42b">&#9670;&#160;</a></span>new_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> yask::yc_solution::new_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional variable in the solution. </p>
<p>"Var" is a generic term for any n-dimensional variable. A 0-dim var is a scalar, a 1-dim var is a vector, a 2-dim var is a matrix, etc.</p>
<p>The dimensions of a variable are defined by providing a list of indices created via <a class="el" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1" title="Create a step-index node.">yc_node_factory::new_step_index()</a>, <a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315" title="Create a domain-index node.">yc_node_factory::new_domain_index()</a>, and/or <a class="el" href="classyask_1_1yc__node__factory.html#aef5fed8db0e1798b421c4a8cb8da77ff" title="Create a new miscellaneous index.">yc_node_factory::new_misc_index()</a>. When a step index is used, it must be the first index. If more than one var uses a step-index, the step-indices must have the same name. For example, you cannot have one var with step-index "t" and one with step-index "time".</p>
<p>Example code to create a solution with an equation for a variable named "A": </p><div class="fragment"><div class="line"><a class="code hl_class" href="classyask_1_1yc__factory.html">yc_factory</a> ycfac;</div>
<div class="line"><a class="code hl_class" href="classyask_1_1yc__node__factory.html">yc_node_factory</a> nfac;</div>
<div class="line"><span class="keyword">auto</span> my_soln = ycfac.<a class="code hl_function" href="classyask_1_1yc__factory.html#adce155773c9b0d469263303919681d69">new_solution</a>(<span class="stringliteral">&quot;my_stencil&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> t = nfac.<a class="code hl_function" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1">new_step_index</a>(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> x = nfac.<a class="code hl_function" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315">new_domain_index</a>(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> y = nfac.<a class="code hl_function" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315">new_domain_index</a>(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> a = ycfac.new_var(<span class="stringliteral">&quot;A&quot;</span>, { t, x, y }); </div>
<div class="line">a-&gt;new_var_point({t+1, x, y}) <a class="code hl_define" href="group__yc.html#gab2a4ef94be4de8ea1367833c9b783038">EQUALS</a> (a-&gt;new_var_point({t, x, y}) +</div>
<div class="line">                                       a-&gt;new_var_point({t, x+1, y}) + </div>
<div class="line">                                       a-&gt;new_var_point({t, x, y+1})) * (1.0/3.0);</div>
<div class="ttc" id="aclassyask_1_1yc__factory_html"><div class="ttname"><a href="classyask_1_1yc__factory.html">yask::yc_factory</a></div><div class="ttdoc">Bootstrap factory to create objects needed to define a stencil solution.</div><div class="ttdef"><b>Definition:</b> yask_compiler_api.hpp:96</div></div>
<div class="ttc" id="aclassyask_1_1yc__factory_html_adce155773c9b0d469263303919681d69"><div class="ttname"><a href="classyask_1_1yc__factory.html#adce155773c9b0d469263303919681d69">yask::yc_factory::new_solution</a></div><div class="ttdeci">virtual yc_solution_ptr new_solution(const std::string &amp;name) const</div><div class="ttdoc">Create a stencil solution.</div></div>
<div class="ttc" id="aclassyask_1_1yc__node__factory_html"><div class="ttname"><a href="classyask_1_1yc__node__factory.html">yask::yc_node_factory</a></div><div class="ttdoc">Factory to create AST nodes.</div><div class="ttdef"><b>Definition:</b> yc_node_api.hpp:607</div></div>
<div class="ttc" id="aclassyask_1_1yc__node__factory_html_a77c772e8539b116a9f0adbdf432628a1"><div class="ttname"><a href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1">yask::yc_node_factory::new_step_index</a></div><div class="ttdeci">virtual yc_index_node_ptr new_step_index(const std::string &amp;name) const</div><div class="ttdoc">Create a step-index node.</div></div>
<div class="ttc" id="aclassyask_1_1yc__node__factory_html_afaa80f553161f4cc4b14b5858f85e315"><div class="ttname"><a href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315">yask::yc_node_factory::new_domain_index</a></div><div class="ttdeci">virtual yc_index_node_ptr new_domain_index(const std::string &amp;name) const</div><div class="ttdoc">Create a domain-index node.</div></div>
<div class="ttc" id="agroup__yc_html_gab2a4ef94be4de8ea1367833c9b783038"><div class="ttname"><a href="group__yc.html#gab2a4ef94be4de8ea1367833c9b783038">EQUALS</a></div><div class="ttdeci">#define EQUALS</div><div class="ttdoc">Recommended macro to make the &quot;equality&quot; operator readable and self-explanatory.</div><div class="ttdef"><b>Definition:</b> yc_node_api.hpp:1084</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__var.html">yc_var</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the new var; must be a valid C++ identifier and unique across vars.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the var. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4daa8ae2e61c612cdb79241e43b34fcc" name="a4daa8ae2e61c612cdb79241e43b34fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4daa8ae2e61c612cdb79241e43b34fcc">&#9670;&#160;</a></span>new_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> yask::yc_solution::new_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional variable in the solution. </p>
<p>C++ initializer-list version with same semantics as the vector version of <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">new_var()</a>. </p><dl class="section note"><dt>Note</dt><dd>Not available in the Python API. Use the vector version. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__var.html">yc_var</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the new var; must be a valid C++ identifier and unique across vars.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the var. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac025854d8d7a0e4c62753dda67ff9e39" name="ac025854d8d7a0e4c62753dda67ff9e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac025854d8d7a0e4c62753dda67ff9e39">&#9670;&#160;</a></span>new_scratch_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> yask::yc_solution::new_scratch_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional scratch variable in the solution. </p>
<p>A scratch variable is a temporary variable used as an intermediate value in an equation.</p><ul>
<li>Scratch vars are not accessible via kernel APIs. Thus, they cannot be programmatically read from or written to.</li>
<li>Scratch var values must be defined from equations ultimately referencing only non-scratch var values, optionally referencing other intermediate scratch-vars.</li>
<li>Scratch vars cannot use the step-index as a dimension.</li>
</ul>
<p>See <code>TestScratchStencil*</code> classes in <code>src/stencils/SimpleTestStencils.hpp</code> for usage examples.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__var.html">yc_var</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the new var; must be a valid C++ identifier and unique across vars.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the var. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3f1bd432ae6b977d8a150e319856228" name="aa3f1bd432ae6b977d8a150e319856228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f1bd432ae6b977d8a150e319856228">&#9670;&#160;</a></span>new_scratch_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> yask::yc_solution::new_scratch_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional scratch variable in the solution. </p>
<p>C++ initializer-list version with same semantics as the vector version of <a class="el" href="classyask_1_1yc__solution.html#ac025854d8d7a0e4c62753dda67ff9e39" title="Create an n-dimensional scratch variable in the solution.">new_scratch_var()</a>. </p><dl class="section note"><dt>Note</dt><dd>Not available in the Python API. Use the vector version. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__var.html">yc_var</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the new var; must be a valid C++ identifier and unique across vars.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the var. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab49cc384ea0686e075885fdd79a0bae9" name="ab49cc384ea0686e075885fdd79a0bae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49cc384ea0686e075885fdd79a0bae9">&#9670;&#160;</a></span>get_num_vars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yc_solution::get_num_vars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vars in the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of vars that have been created via <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">new_var()</a> or <a class="el" href="classyask_1_1yc__solution.html#ac025854d8d7a0e4c62753dda67ff9e39" title="Create an n-dimensional scratch variable in the solution.">new_scratch_var()</a>. </dd></dl>

</div>
</div>
<a id="a3a126f887a0c6b206844fc84bcc4c9e0" name="a3a126f887a0c6b206844fc84bcc4c9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a126f887a0c6b206844fc84bcc4c9e0">&#9670;&#160;</a></span>get_vars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> &gt; yask::yc_solution::get_vars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vars in the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector containing pointer to all vars. </dd></dl>

</div>
</div>
<a id="a8c6711eac1757a98387c4a90b9f7802c" name="a8c6711eac1757a98387c4a90b9f7802c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6711eac1757a98387c4a90b9f7802c">&#9670;&#160;</a></span>get_var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga90f589d7fb0dc32e895384b65140f4a3">yc_var_ptr</a> yask::yc_solution::get_var </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the specified var. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the specified var or null pointer if it does not exist. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the var. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1168b5b8044e39c047d81a5fe5efc06e" name="a1168b5b8044e39c047d81a5fe5efc06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1168b5b8044e39c047d81a5fe5efc06e">&#9670;&#160;</a></span>set_fold_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_fold_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the vectorization length in given dimension. </p>
<p>For YASK-code generation, the product of the fold lengths should be equal to the number of elements in a HW SIMD register. The number of elements in a HW SIMD register is determined by the number of bytes in an element and the print format.</p>
<p>Example: For SP FP elements in AVX-512 vectors, the product of the fold lengths should be 16, e.g., x=4 and y=4.</p>
<p>If the product of the fold lengths is <em>not</em> the number of elements in a HW SIMD register, the fold lengths will be adjusted based on an internal heuristic. In this heuristic, any specified fold length is used as a hint to determine the final folding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension of fold, e.g., "x". This must be an index created by new_domain_index().</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of vectorization in <code>dim</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaefa9675e9551ec10b9eee0016a0822" name="abaefa9675e9551ec10b9eee0016a0822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaefa9675e9551ec10b9eee0016a0822">&#9670;&#160;</a></span>is_folding_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yc_solution::is_folding_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether any folding has been set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any fold length has been specified; <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a45cb1df4af6886e82f98904473873272" name="a45cb1df4af6886e82f98904473873272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cb1df4af6886e82f98904473873272">&#9670;&#160;</a></span>set_cluster_mult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_cluster_mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cluster multiplier (unroll factor) in given dimension. </p>
<p>For YASK kernel-code generation, this will have the effect of creating N vectors of output for each equation, where N is the product of the cluster multipliers.</p>
<dl class="section note"><dt>Note</dt><dd>A multiplier &gt;1 cannot be applied to the step dimension. </dd>
<dd>
Default is one (1) in each dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Direction of unroll, e.g., "y". This must be an index created by new_domain_index().</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mult</td><td>Number of vectors in <code>dim</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8927aebccf305d7224d6bc3dafb8f263" name="a8927aebccf305d7224d6bc3dafb8f263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8927aebccf305d7224d6bc3dafb8f263">&#9670;&#160;</a></span>is_clustering_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yc_solution::is_clustering_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether any clustering has been set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any cluster multiple has been specified; <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a2c0d2dad6b123d0a1444e2f2a74d1ad4" name="a2c0d2dad6b123d0a1444e2f2a74d1ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0d2dad6b123d0a1444e2f2a74d1ad4">&#9670;&#160;</a></span>get_num_equations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yc_solution::get_num_equations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of equations in the solution. </p>
<p>Equations are added when <a class="el" href="classyask_1_1yc__node__factory.html#a65838f8b97438cf4841644cff88dfb14" title="Create an equation node.">yc_node_factory::new_equation_node()</a> is called. </p><dl class="section return"><dt>Returns</dt><dd>Number of equations that have been created. </dd></dl>

</div>
</div>
<a id="a96b08588481e1fd41bc8d6ae74743a88" name="a96b08588481e1fd41bc8d6ae74743a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b08588481e1fd41bc8d6ae74743a88">&#9670;&#160;</a></span>get_equations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> &gt; yask::yc_solution::get_equations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all the defined equations. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of containing pointers to all equations that have been created. </dd></dl>

</div>
</div>
<a id="abe595d131a70b3ef881e4e2ab35b47d6" name="abe595d131a70b3ef881e4e2ab35b47d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe595d131a70b3ef881e4e2ab35b47d6">&#9670;&#160;</a></span>get_prefetch_dist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yc_solution::get_prefetch_dist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current prefetch distance for the given cache. </p>
<dl class="section return"><dt>Returns</dt><dd>Prefetch distance in number of iterations or zero (0) if disabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Cache level: 1 or 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa849ba0ae1af7890d8f6f5c0b095ff25" name="aa849ba0ae1af7890d8f6f5c0b095ff25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa849ba0ae1af7890d8f6f5c0b095ff25">&#9670;&#160;</a></span>set_prefetch_dist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_prefetch_dist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the prefetch distance for the given cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Cache level: 1 or 2.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Number of iterations ahead to prefetch data or zero (0) to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c18b4c2eba024a830d5e43c83df958b" name="a9c18b4c2eba024a830d5e43c83df958b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c18b4c2eba024a830d5e43c83df958b">&#9670;&#160;</a></span>output_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::output_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a>&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimize and the current equation(s) and write to given output object. </p>
<p>Output will be formatted according to <a class="el" href="classyask_1_1yc__solution.html#a1c03fc69e306a700de8c5ae3973229c2" title="Set the output target.">set_target()</a> and all other preceding YASK compiler API calls.</p>
<p>Progress text will be written to the output stream set via <a class="el" href="classyask_1_1yc__solution.html#aff540803d358a5dcd304f09c522ec867" title="Set object to receive debug output.">set_debug_output()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd><em>Side effect:</em> Applies optimizations to the equation(s), so some pointers to nodes in the original equations may refer to modified nodes or nodes that have been optimized away after calling <a class="el" href="classyask_1_1yc__solution.html#a5f3624ded964c465724fd0221d5a2aaa" title="[Deprecated] Use set_target() and output_solution().">format()</a>. In general, do not use pointers to nodes across calls to <a class="el" href="classyask_1_1yc__solution.html#a5f3624ded964c465724fd0221d5a2aaa" title="[Deprecated] Use set_target() and output_solution().">format()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to object to receive formatted output. See <a class="el" href="classyask_1_1yask__output__factory.html">yask_output_factory</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa669130ec18bcf1fa9a5090aa6b510d7" name="aa669130ec18bcf1fa9a5090aa6b510d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa669130ec18bcf1fa9a5090aa6b510d7">&#9670;&#160;</a></span>call_before_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::call_before_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyask_1_1yc__solution.html#ad24c46b2a6d40b0c2af867157dcea826">output_hook_t</a>&#160;</td>
          <td class="paramname"><em>hook_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Register a function to be called before a solution is output. </p>
<p>The registered functions will be called during a call to <a class="el" href="classyask_1_1yc__solution.html#a9c18b4c2eba024a830d5e43c83df958b" title="Optimize and the current equation(s) and write to given output object.">output_solution()</a> after the equations optimizations have been applied but before the output is written.</p>
<p>A reference to the solution and the parameter to <a class="el" href="classyask_1_1yc__solution.html#a9c18b4c2eba024a830d5e43c83df958b" title="Optimize and the current equation(s) and write to given output object.">output_solution()</a> are passed to the <code>hook_fn</code>.</p>
<p>If this method is called more than once, the hook functions will be called in the order registered.</p>
<dl class="section note"><dt>Note</dt><dd>Not available in the Python API. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hook_fn</td><td>callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c837c7eca24ad461fb977c48f4237ce" name="a7c837c7eca24ad461fb977c48f4237ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c837c7eca24ad461fb977c48f4237ce">&#9670;&#160;</a></span>call_after_new_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::call_after_new_solution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add block of custom C++ code to the kernel solution. </p>
<p>This block of code will be executed immediately after the stencil solution is constructed in the kernel, i.e., at the end of a call to <a class="el" href="classyask_1_1yk__factory.html#a755b1bfc0dd9bfddfe80d924a188b350" title="Create a stencil solution.">yk_factory::new_solution()</a>. The code may access the new solution via the reference <code>kernel_soln</code> of type <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a>.</p>
<p>Common uses of this facility include setting default run-time settings such as block sizes and registering call-back routines, e.g., via <a class="el" href="classyask_1_1yk__solution.html#aeaa3d7e75bfcde066f1ea8b2871ced4b" title="[Advanced] Register a function to be called at the beginning of yk_solution::prepare_solution().">yk_solution::call_before_prepare_solution()</a>;</p>
<p>Unlike <a class="el" href="classyask_1_1yk__solution.html#aeaa3d7e75bfcde066f1ea8b2871ced4b" title="[Advanced] Register a function to be called at the beginning of yk_solution::prepare_solution().">yk_solution::call_before_prepare_solution()</a> and similar functions which have <code>std::function</code> parameters, the parameter to this function is a string because the code is not compiled (or compilable) until the kernel library is built.</p>
<p>Alternatively, equivalent code can be added directly to any custom application using the kernel library APIs. However, this function is useful when using the provided YASK kernel-performance utility launched via <code>bin/yask.sh</code>. It also provides a method to provide consistent kernel code when the kernel library is used in multiple applications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>Code to be inserted, using <code>kernel_soln</code> of type <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> to access the kernel solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dc810afcb4ef91c10aa5e0e7092476f" name="a3dc810afcb4ef91c10aa5e0e7092476f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc810afcb4ef91c10aa5e0e7092476f">&#9670;&#160;</a></span>set_domain_dims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_domain_dims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Explicitly define and order the domain dimensions used in the solution. </p>
<p>The order of domain dimensions affects memory layout, looping order, vector-folding, and rank layout. This API also allows specification of the domain dimensions in the unusual case where a solution is defined without any vars containing all of the domain dimensions. Whether or not this API is called, domain dimension(s) are added when <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">new_var()</a> or <a class="el" href="classyask_1_1yc__solution.html#ac025854d8d7a0e4c62753dda67ff9e39" title="Create an n-dimensional scratch variable in the solution.">new_scratch_var()</a> is called with one or more domain dimensions not previously seen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Domain dimensions of the solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab798850bc3a6bf88322a2f39765ee831" name="ab798850bc3a6bf88322a2f39765ee831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab798850bc3a6bf88322a2f39765ee831">&#9670;&#160;</a></span>set_domain_dims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_domain_dims </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Explicitly define and order the domain dimensions used in the solution. </p>
<p>C++ initializer-list version with same semantics as the vector version of <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">new_var()</a>. </p><dl class="section note"><dt>Note</dt><dd>Not available in the Python API. Use the vector version. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Domain dimensions of the solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad234ecd4964bcb57b1876be87baf57bd" name="ad234ecd4964bcb57b1876be87baf57bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad234ecd4964bcb57b1876be87baf57bd">&#9670;&#160;</a></span>set_step_dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_step_dim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Explicitly identify the step dimension in the solution. </p>
<p>By default, the step dimension is defined when <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">new_var()</a> is called with a step index. This API allows specification of the step dimension in the unusual case where a solution is defined without any vars containing the step dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Step dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac181c24ab7af945318a055cef3b52ee6" name="ac181c24ab7af945318a055cef3b52ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac181c24ab7af945318a055cef3b52ee6">&#9670;&#160;</a></span>set_dependency_checker_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_dependency_checker_enabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Enable or disable automatic dependency checker. </p>
<p>Disabling the built-in dependency checker may be done when it is overly conservative. Currently, the provided checker does not allow stencils in which points in one sub-domain depend on points in another sub-domain within the same value of the step index.</p>
<dl class="section warning"><dt>Warning</dt><dd>If dependency checker is disabled, <em>all</em> dependencies must be set via <a class="el" href="classyask_1_1yc__solution.html#a727a91bb87e42de9822ac6540e3fc93e" title="[Advanced] Add a dependency between two equations.">add_flow_dependency()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b4a7ac8cc9e6be09b115a106bac769b" name="a8b4a7ac8cc9e6be09b115a106bac769b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4a7ac8cc9e6be09b115a106bac769b">&#9670;&#160;</a></span>is_dependency_checker_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yc_solution::is_dependency_checker_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine whether automatic dependency checker is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting. </dd></dl>

</div>
</div>
<a id="a727a91bb87e42de9822ac6540e3fc93e" name="a727a91bb87e42de9822ac6540e3fc93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727a91bb87e42de9822ac6540e3fc93e">&#9670;&#160;</a></span>add_flow_dependency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::add_flow_dependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a dependency between two equations. </p>
<p>This function adds an arc in the data-dependency graph <code>from</code> one equation (node) <code>to</code> another one, indicating that the <code>from</code> equation depends on the <code>to</code> equation. In other words, the <code>to</code> expression must be evaluated <em>before</em> the <code>from</code> equation. In compiler-theory terms, this is a <em>flow</em> dependency, also known as a <em>true</em> or <em>read-after-write</em> (RAW) dependency. (Strictly speaking, however, equations in the YASK compiler are declarative instead of imperative, so they describe equalities rather than assignments with reads and writes. On the other hand, a C++ function created to implement one or more equations will perform analogous reads and writes.)</p>
<p>Additional considerations:</p>
<ul>
<li>It is not necessary to connect all the equations into a single graph. For example, if <b>A</b> depends on <b>B</b> and <b>C</b> depends on <b>D</b>, there will be two disconnected subgraphs. In this example, the YASK kernel is free to 1) schedule the functions created for B** and <b>D</b> to run together in parallel followed by those for A** and <b>C</b> together in parallel, 2) run a single function that implements both <b>B</b> and <b>D</b> simultaneously followed by a single function that implements both <b>A</b> and <b>C</b> simultaneously, or 3) a combination of the implementations.</li>
<li>Only <em>immediate</em> dependencies should be added. In other words, each subgraph created should be a transitive reduction. For example, if <b>A</b> depends on <b>B</b> and <b>B</b> depends on <b>C</b>, it is not necessary to add the transitive dependence from <b>A</b> to <b>C</b>.</li>
<li>Only dependencies at a given step-index value should be added. For example, given equation <b>A</b>: <code>A(t+1, x) EQUALS B(t+1, x) + 5</code> and equation <b>B</b>: <code>B(t+1, x) EQUALS A(t, x) / 2</code>, A** depends on <b>B</b> at some value of the step-index <code>t</code>. That dependency should be added if the automatic checker is disabled. (It is true that the next value of <code>B(t+2)</code> depends on <code>A(t+1)</code>, but such inter-step &ndash; analgous to loop-carried &ndash; dependencies should <em>not</em> be added with this function.)</li>
<li>The dependencies should create one or more directed acyclic graphs (DAGs). If a cycle is created, the YASK compiler will throw an exception containing an error message about a circular dependency. This exception may not be thrown until <a class="el" href="classyask_1_1yc__solution.html#a5f3624ded964c465724fd0221d5a2aaa" title="[Deprecated] Use set_target() and output_solution().">format()</a> is called.</li>
<li>If using scratch vars, dependencies among scratch vars and between scratch equations and non-scratch equations should also be added. Each scratch equation should ultimately depend on non-scratch values.</li>
<li>This function can be used in cooperation with or instead of the built-in automatic dependency checker. When used in cooperation with the built-in checker, both dependencies from this function and the built-in checker will be considered. When the built-in checker is diabled via <code>set_dependency_checker_enabled(false)</code>, only dependencies from this function will be considered. In this case, it is imperative that all immediate dependencies are added. If the dependency graph is incomplete, the resulting generated stencil code will contain illegal race conditions, and it will most likely produce incorrect results. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Equation that must be evaluated <em>after</em> <code>to</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Equation that must be evaluated <em>before</em> <code>from</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42cd08d7a26c93d5073134f3b76dcc38" name="a42cd08d7a26c93d5073134f3b76dcc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cd08d7a26c93d5073134f3b76dcc38">&#9670;&#160;</a></span>clear_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::clear_dependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Remove all existing dependencies. </p>
<p>Removes dependencies added via <a class="el" href="classyask_1_1yc__solution.html#a727a91bb87e42de9822ac6540e3fc93e" title="[Advanced] Add a dependency between two equations.">add_flow_dependency()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="yask__compiler__api_8hpp_source.html">yask_compiler_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
