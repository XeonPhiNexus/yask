<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YASK: yask::yc_node_factory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kit: a software framework for creating HPC stencil code. Copyright 2014-2023 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yask</b></li><li class="navelem"><a class="el" href="classyask_1_1yc__node__factory.html">yc_node_factory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyask_1_1yc__node__factory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">yask::yc_node_factory Class Reference<div class="ingroups"><a class="el" href="group__yc.html">YASK Compiler</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Factory to create AST nodes.  
 <a href="classyask_1_1yc__node__factory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="yc__node__api_8hpp_source.html">yc_node_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77c772e8539b116a9f0adbdf432628a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1">new_step_index</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a77c772e8539b116a9f0adbdf432628a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a step-index node.  <br /></td></tr>
<tr class="separator:a77c772e8539b116a9f0adbdf432628a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa80f553161f4cc4b14b5858f85e315"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315">new_domain_index</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:afaa80f553161f4cc4b14b5858f85e315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a domain-index node.  <br /></td></tr>
<tr class="separator:afaa80f553161f4cc4b14b5858f85e315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5fed8db0e1798b421c4a8cb8da77ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#aef5fed8db0e1798b421c4a8cb8da77ff">new_misc_index</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aef5fed8db0e1798b421c4a8cb8da77ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new miscellaneous index.  <br /></td></tr>
<tr class="separator:aef5fed8db0e1798b421c4a8cb8da77ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65838f8b97438cf4841644cff88dfb14"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a65838f8b97438cf4841644cff88dfb14">new_equation_node</a> (<a class="el" href="group__yc.html#ga9a62b44ca70077bbedfd93527c87c56e">yc_var_point_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs, <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> sub_domain_cond=nullptr) const</td></tr>
<tr class="memdesc:a65838f8b97438cf4841644cff88dfb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an equation node.  <br /></td></tr>
<tr class="separator:a65838f8b97438cf4841644cff88dfb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ad1075e359ddf1100ec25432b869b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#ad7ad1075e359ddf1100ec25432b869b3">new_number_node</a> (<a class="el" href="classyask_1_1yc__number__any__arg.html">yc_number_any_arg</a> arg) const</td></tr>
<tr class="memdesc:ad7ad1075e359ddf1100ec25432b869b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical-value expression node.  <br /></td></tr>
<tr class="separator:ad7ad1075e359ddf1100ec25432b869b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cea213b263ba7e29ad940ba1bb1e123"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a8cea213b263ba7e29ad940ba1bb1e123">new_const_number_node</a> (double val) const</td></tr>
<tr class="memdesc:a8cea213b263ba7e29ad940ba1bb1e123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant numerical-value node.  <br /></td></tr>
<tr class="separator:a8cea213b263ba7e29ad940ba1bb1e123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fdf34429bb3f5f175fbf8a1bbb21d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#ad5fdf34429bb3f5f175fbf8a1bbb21d7">new_const_number_node</a> (<a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a> val) const</td></tr>
<tr class="memdesc:ad5fdf34429bb3f5f175fbf8a1bbb21d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant numerical value node.  <br /></td></tr>
<tr class="separator:ad5fdf34429bb3f5f175fbf8a1bbb21d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e3d4a1d08812ffb9d39d486d34822e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a45e3d4a1d08812ffb9d39d486d34822e">new_negate_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a45e3d4a1d08812ffb9d39d486d34822e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical negation operator node.  <br /></td></tr>
<tr class="separator:a45e3d4a1d08812ffb9d39d486d34822e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24023bd93c3579b68a0c5098420364d8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a24023bd93c3579b68a0c5098420364d8">new_add_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a24023bd93c3579b68a0c5098420364d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an addition node.  <br /></td></tr>
<tr class="separator:a24023bd93c3579b68a0c5098420364d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc5a1c213ed371b67df77c1087f586d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a1cc5a1c213ed371b67df77c1087f586d">new_multiply_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a1cc5a1c213ed371b67df77c1087f586d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a multiplication node.  <br /></td></tr>
<tr class="separator:a1cc5a1c213ed371b67df77c1087f586d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ec670eeb91d4f4a7b4a9221a808346"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#af6ec670eeb91d4f4a7b4a9221a808346">new_subtract_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:af6ec670eeb91d4f4a7b4a9221a808346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a subtraction node.  <br /></td></tr>
<tr class="separator:af6ec670eeb91d4f4a7b4a9221a808346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2a0639eb867d9c8369fcec92dd1201"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a4a2a0639eb867d9c8369fcec92dd1201">new_divide_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a4a2a0639eb867d9c8369fcec92dd1201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a division node.  <br /></td></tr>
<tr class="separator:a4a2a0639eb867d9c8369fcec92dd1201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d7ca74b83c874c2c9602dc7999c9a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a64d7ca74b83c874c2c9602dc7999c9a6">new_mod_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a64d7ca74b83c874c2c9602dc7999c9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a modulo node.  <br /></td></tr>
<tr class="separator:a64d7ca74b83c874c2c9602dc7999c9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd88810e4573968726a192c24b49c014"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#acd88810e4573968726a192c24b49c014">new_first_domain_index</a> (<a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> idx) const</td></tr>
<tr class="memdesc:acd88810e4573968726a192c24b49c014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol for the first index value in a given dimension.  <br /></td></tr>
<tr class="separator:acd88810e4573968726a192c24b49c014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22990dbd10e7724e10d3920ca37cebd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#ad22990dbd10e7724e10d3920ca37cebd">new_last_domain_index</a> (<a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> idx) const</td></tr>
<tr class="memdesc:ad22990dbd10e7724e10d3920ca37cebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol for the last index value in a given dimension.  <br /></td></tr>
<tr class="separator:ad22990dbd10e7724e10d3920ca37cebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9462ce682c61055dd24fb0c06ed829cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a9462ce682c61055dd24fb0c06ed829cb">new_not_node</a> (<a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a9462ce682c61055dd24fb0c06ed829cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a binary inverse operator node.  <br /></td></tr>
<tr class="separator:a9462ce682c61055dd24fb0c06ed829cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ecfb721711e2d87f268be14892c9a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#ad2ecfb721711e2d87f268be14892c9a3">new_and_node</a> (<a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:ad2ecfb721711e2d87f268be14892c9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a boolean 'and' node.  <br /></td></tr>
<tr class="separator:ad2ecfb721711e2d87f268be14892c9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b4735896225d361d2a7c450226162d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a73b4735896225d361d2a7c450226162d">new_or_node</a> (<a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a73b4735896225d361d2a7c450226162d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a boolean 'or' node.  <br /></td></tr>
<tr class="separator:a73b4735896225d361d2a7c450226162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9684a3337db7087ff9f7e190ce706969"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a9684a3337db7087ff9f7e190ce706969">new_equals_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a9684a3337db7087ff9f7e190ce706969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical-comparison 'equals' node.  <br /></td></tr>
<tr class="separator:a9684a3337db7087ff9f7e190ce706969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff404fd16e133b0428945aad5519f2dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#aff404fd16e133b0428945aad5519f2dc">new_not_equals_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:aff404fd16e133b0428945aad5519f2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical-comparison 'not-equals' node.  <br /></td></tr>
<tr class="separator:aff404fd16e133b0428945aad5519f2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fcf62243eee64f4d8e06224b2e6de7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#af5fcf62243eee64f4d8e06224b2e6de7">new_less_than_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:af5fcf62243eee64f4d8e06224b2e6de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical-comparison 'less-than' node.  <br /></td></tr>
<tr class="separator:af5fcf62243eee64f4d8e06224b2e6de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab917cf34e4a230e090d8fdae04796037"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#ab917cf34e4a230e090d8fdae04796037">new_greater_than_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:ab917cf34e4a230e090d8fdae04796037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical-comparison 'greater-than' node.  <br /></td></tr>
<tr class="separator:ab917cf34e4a230e090d8fdae04796037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f679bd94fbaae4c0bf77bd779cb843e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a8f679bd94fbaae4c0bf77bd779cb843e">new_not_less_than_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a8f679bd94fbaae4c0bf77bd779cb843e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical-comparison 'greater-than or equals' node.  <br /></td></tr>
<tr class="separator:a8f679bd94fbaae4c0bf77bd779cb843e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305c26cefe30302d72a1155f41139298"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__node__factory.html#a305c26cefe30302d72a1155f41139298">new_not_greater_than_node</a> (<a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> lhs, <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> rhs) const</td></tr>
<tr class="memdesc:a305c26cefe30302d72a1155f41139298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a numerical-comparison 'less-than or equals' node.  <br /></td></tr>
<tr class="separator:a305c26cefe30302d72a1155f41139298"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Factory to create AST nodes. </p>
<dl class="section note"><dt>Note</dt><dd>Var-point reference nodes are created from a <a class="el" href="classyask_1_1yc__var.html">yc_var</a> object instead of from a <a class="el" href="classyask_1_1yc__node__factory.html">yc_node_factory</a>. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a77c772e8539b116a9f0adbdf432628a1" name="a77c772e8539b116a9f0adbdf432628a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c772e8539b116a9f0adbdf432628a1">&#9670;&#160;</a></span>new_step_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> yask::yc_node_factory::new_step_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a step-index node. </p>
<p>Create a variable to be used to index vars in the solution-step dimension. The name usually describes time, e.g. "t". </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__index__node.html">yc_index_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Step dimension name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaa80f553161f4cc4b14b5858f85e315" name="afaa80f553161f4cc4b14b5858f85e315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa80f553161f4cc4b14b5858f85e315">&#9670;&#160;</a></span>new_domain_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> yask::yc_node_factory::new_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a domain-index node. </p>
<p>Create a variable to be used to index vars in the solution-domain dimension. The name usually describes spatial dimensions, e.g. "x" or "y", but it can be any dimension that is specified at run-time, such as an index into a number of parallel problems being solved simultaneously.</p>
<dl class="section note"><dt>Note</dt><dd>This should <em>not</em> include the step dimension, which is specified via <a class="el" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1" title="Create a step-index node.">new_step_index()</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__index__node.html">yc_index_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Domain index name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef5fed8db0e1798b421c4a8cb8da77ff" name="aef5fed8db0e1798b421c4a8cb8da77ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5fed8db0e1798b421c4a8cb8da77ff">&#9670;&#160;</a></span>new_misc_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> yask::yc_node_factory::new_misc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new miscellaneous index. </p>
<p>Create an variable to be used to index vars in the some dimension that is not the step dimension or a domain dimension. The value of these indices are normally compile-time constants, e.g., a fixed index into an array. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__index__node.html">yc_index_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Index name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65838f8b97438cf4841644cff88dfb14" name="a65838f8b97438cf4841644cff88dfb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65838f8b97438cf4841644cff88dfb14">&#9670;&#160;</a></span>new_equation_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> yask::yc_node_factory::new_equation_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga9a62b44ca70077bbedfd93527c87c56e">yc_var_point_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td>
          <td class="paramname"><em>sub_domain_cond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an equation node. </p>
<p>Indicates var point on LHS is equivalent to expression on RHS. This is NOT a test for equality. When an equation is created, it is automatically added to the list of equations for the <a class="el" href="classyask_1_1yc__solution.html" title="Stencil solution.">yc_solution</a> that contains the var that is on the LHS.</p>
<p>An optional domain condition may be provided to define the sub-domain to which this equation applies. Domain conditions are always evaluated with respect to the overall problem domain, i.e., independent of any specific MPI domain decomposition that might occur at run-time. If a domain condition is not provided, the equation applies to the entire problem domain. A domain condition can be added to an equation after its creation via <a class="el" href="classyask_1_1yc__equation__node.html#ac264942915dfb99fcfc9578873109bdb" title="Set the condition describing the sub-domain for this equation.">yc_equation_node.set_cond()</a>. See <a class="el" href="classyask_1_1yc__equation__node.html#ac264942915dfb99fcfc9578873109bdb" title="Set the condition describing the sub-domain for this equation.">yc_equation_node.set_cond()</a> for more information and an example.</p>
<p>A step condition is similar to a domain condition, but enables or disables the entire equation based on the current step (usually time) and/or other values. A step condition can only be added to an equation after its creation via <a class="el" href="classyask_1_1yc__equation__node.html#ac0b218c653b1f341ef05e30562051c22" title="Set the condition describing when the equation is valid.">yc_equation_node.set_step_cond()</a>. See <a class="el" href="classyask_1_1yc__equation__node.html#ac0b218c653b1f341ef05e30562051c22" title="Set the condition describing when the equation is valid.">yc_equation_node.set_step_cond()</a> for more information and an example.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__equation__node.html">yc_equation_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Var-point before EQUALS operator.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after EQUALS operator.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_domain_cond</td><td>Optional expression defining sub-domain where <code>lhs EQUALS rhs</code> is valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7ad1075e359ddf1100ec25432b869b3" name="ad7ad1075e359ddf1100ec25432b869b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ad1075e359ddf1100ec25432b869b3">&#9670;&#160;</a></span>new_number_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_number_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyask_1_1yc__number__any__arg.html">yc_number_any_arg</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical-value expression node. </p>
<p>A generic method to create a pointer to a numerical expression from any type supported by <a class="el" href="classyask_1_1yc__number__any__arg.html">yc_number_any_arg</a> constructors. </p><dl class="section note"><dt>Note</dt><dd>Not available in Python API. Use a more explicit method. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Argument to convert to a numerical expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cea213b263ba7e29ad940ba1bb1e123" name="a8cea213b263ba7e29ad940ba1bb1e123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cea213b263ba7e29ad940ba1bb1e123">&#9670;&#160;</a></span>new_const_number_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_const_number_node </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a constant numerical-value node. </p>
<p>Use to add a constant to an expression. The overloaded arithmetic operators allow <code>double</code> arguments, so in most cases, it is not necessary to call this directly. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__const__number__node.html">yc_const_number_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to store in node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5fdf34429bb3f5f175fbf8a1bbb21d7" name="ad5fdf34429bb3f5f175fbf8a1bbb21d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fdf34429bb3f5f175fbf8a1bbb21d7">&#9670;&#160;</a></span>new_const_number_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_const_number_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga1dd7066686ff93559a0f28979be12d81">idx_t</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a constant numerical value node. </p>
<p>Integer version of new_const_number_node(double). It may be necessary to cast other integer types to <code>idx_t</code> to avoid ambiguous overloading of this function. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__const__number__node.html">yc_const_number_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to store in node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e3d4a1d08812ffb9d39d486d34822e" name="a45e3d4a1d08812ffb9d39d486d34822e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e3d4a1d08812ffb9d39d486d34822e">&#9670;&#160;</a></span>new_negate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_negate_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical negation operator node. </p>
<p>This is the explicit form, which is usually not needed because new negation nodes can also be created via the overloaded unary <code>-</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__negate__node.html">yc_negate_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>-</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24023bd93c3579b68a0c5098420364d8" name="a24023bd93c3579b68a0c5098420364d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24023bd93c3579b68a0c5098420364d8">&#9670;&#160;</a></span>new_add_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an addition node. </p>
<p>This is the explicit form, which is usually not needed because new addition nodes can also be created via the overloaded <code>+</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__add__node.html">yc_add_node</a> object. Returns <code>rhs</code> if <code>lhs</code> is a null node pointer and vice-versa. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>+</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>+</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cc5a1c213ed371b67df77c1087f586d" name="a1cc5a1c213ed371b67df77c1087f586d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc5a1c213ed371b67df77c1087f586d">&#9670;&#160;</a></span>new_multiply_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_multiply_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a multiplication node. </p>
<p>This is the explicit form, which is usually not needed because new multiplication nodes can also be created via the overloaded <code>*</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__multiply__node.html">yc_multiply_node</a> object. Returns <code>rhs</code> if <code>lhs</code> is a null node pointer and vice-versa. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>*</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>*</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6ec670eeb91d4f4a7b4a9221a808346" name="af6ec670eeb91d4f4a7b4a9221a808346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ec670eeb91d4f4a7b4a9221a808346">&#9670;&#160;</a></span>new_subtract_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_subtract_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a subtraction node. </p>
<p>This is binary subtraction. Use <a class="el" href="classyask_1_1yc__node__factory.html#a45e3d4a1d08812ffb9d39d486d34822e" title="Create a numerical negation operator node.">new_negate_node()</a> for unary <code>-</code>.</p>
<p>This is the explicit form, which is usually not needed because new subtraction nodes can also be created via the overloaded <code>-</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__subtract__node.html">yc_subtract_node</a> object. Returns <code>- rhs</code> if <code>lhs</code> is a null node pointer and <code>lhs</code> if <code>rhs</code> is null. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>-</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>-</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a2a0639eb867d9c8369fcec92dd1201" name="a4a2a0639eb867d9c8369fcec92dd1201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2a0639eb867d9c8369fcec92dd1201">&#9670;&#160;</a></span>new_divide_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_divide_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a division node. </p>
<p>This is the explicit form, which is usually not needed because new division nodes can also be created via the overloaded <code>/</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__divide__node.html">yc_divide_node</a> object. Returns <code>1.0 / rhs</code> if <code>lhs</code> is a null node pointer and <code>lhs</code> if <code>rhs</code> is null. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>/</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>/</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d7ca74b83c874c2c9602dc7999c9a6" name="a64d7ca74b83c874c2c9602dc7999c9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d7ca74b83c874c2c9602dc7999c9a6">&#9670;&#160;</a></span>new_mod_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a> yask::yc_node_factory::new_mod_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a modulo node. </p>
<p>This is the explicit form, which is usually not needed because new modulo nodes can also be created via the overloaded <code>%</code> operator. The modulo operator converts both operands to integers before performing the operation. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__mod__node.html">yc_mod_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>%</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>%</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd88810e4573968726a192c24b49c014" name="acd88810e4573968726a192c24b49c014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd88810e4573968726a192c24b49c014">&#9670;&#160;</a></span>new_first_domain_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> yask::yc_node_factory::new_first_domain_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol for the first index value in a given dimension. </p>
<p>Create an expression that indicates the first value in the overall problem domain in <code>dim</code> dimension. The <code>dim</code> argument is created via <a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315" title="Create a domain-index node.">new_domain_index()</a>.</p>
<p>See <a class="el" href="classyask_1_1yc__equation__node.html#ac264942915dfb99fcfc9578873109bdb" title="Set the condition describing the sub-domain for this equation.">yc_equation_node.set_cond()</a> for more information and an example.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__index__node.html">yc_index_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Domain index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad22990dbd10e7724e10d3920ca37cebd" name="ad22990dbd10e7724e10d3920ca37cebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22990dbd10e7724e10d3920ca37cebd">&#9670;&#160;</a></span>new_last_domain_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> yask::yc_node_factory::new_last_domain_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol for the last index value in a given dimension. </p>
<p>Create an expression that indicates the last value in the overall problem domain in <code>dim</code> dimension. The <code>dim</code> argument is created via <a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315" title="Create a domain-index node.">new_domain_index()</a>.</p>
<p>See <a class="el" href="classyask_1_1yc__equation__node.html#ac264942915dfb99fcfc9578873109bdb" title="Set the condition describing the sub-domain for this equation.">yc_equation_node.set_cond()</a> for more information and an example.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__index__node.html">yc_index_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Domain index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9462ce682c61055dd24fb0c06ed829cb" name="a9462ce682c61055dd24fb0c06ed829cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9462ce682c61055dd24fb0c06ed829cb">&#9670;&#160;</a></span>new_not_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_not_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a binary inverse operator node. </p>
<p>This is the explicit form, which is usually not needed because new "not" nodes can also be created via the overloaded <code>!</code> operator or the <code>yc_not</code> function in Python. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__not__node.html">yc_not_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>!</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2ecfb721711e2d87f268be14892c9a3" name="ad2ecfb721711e2d87f268be14892c9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ecfb721711e2d87f268be14892c9a3">&#9670;&#160;</a></span>new_and_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_and_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a boolean 'and' node. </p>
<p>This is the explicit form, which is usually not needed because new "and" nodes can also be created via the overloaded <code>&amp;&amp;</code> operator or the <code>yc_and</code> function in Python. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__and__node.html">yc_and_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>&amp;&amp;</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>&amp;&amp;</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73b4735896225d361d2a7c450226162d" name="a73b4735896225d361d2a7c450226162d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b4735896225d361d2a7c450226162d">&#9670;&#160;</a></span>new_or_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_or_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a boolean 'or' node. </p>
<p>This is the explicit form, which is usually not needed because new "or" nodes can also be created via the overloaded <code>||</code> operator or the <code>yc_or</code> function in Python. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__or__node.html">yc_or_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>||</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>||</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9684a3337db7087ff9f7e190ce706969" name="a9684a3337db7087ff9f7e190ce706969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9684a3337db7087ff9f7e190ce706969">&#9670;&#160;</a></span>new_equals_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_equals_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical-comparison 'equals' node. </p>
<p>This is the explicit form, which is usually not needed because new "equals" nodes can also be created via the overloaded <code>==</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__equals__node.html">yc_equals_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>==</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>==</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff404fd16e133b0428945aad5519f2dc" name="aff404fd16e133b0428945aad5519f2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff404fd16e133b0428945aad5519f2dc">&#9670;&#160;</a></span>new_not_equals_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_not_equals_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical-comparison 'not-equals' node. </p>
<p>This is the explicit form, which is usually not needed because new "not-equals" nodes can also be created via the overloaded <code>!=</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__not__equals__node.html">yc_not_equals_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>!=</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>!=</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5fcf62243eee64f4d8e06224b2e6de7" name="af5fcf62243eee64f4d8e06224b2e6de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fcf62243eee64f4d8e06224b2e6de7">&#9670;&#160;</a></span>new_less_than_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_less_than_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical-comparison 'less-than' node. </p>
<p>This is the explicit form, which is usually not needed because new "less-than" nodes can also be created via the overloaded <code>&lt;</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__less__than__node.html">yc_less_than_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>&lt;</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>&lt;</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab917cf34e4a230e090d8fdae04796037" name="ab917cf34e4a230e090d8fdae04796037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab917cf34e4a230e090d8fdae04796037">&#9670;&#160;</a></span>new_greater_than_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_greater_than_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical-comparison 'greater-than' node. </p>
<p>This is the explicit form, which is usually not needed because new "greater-than" nodes can also be created via the overloaded <code>&gt;</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__greater__than__node.html">yc_greater_than_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>&gt;</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>&gt;</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f679bd94fbaae4c0bf77bd779cb843e" name="a8f679bd94fbaae4c0bf77bd779cb843e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f679bd94fbaae4c0bf77bd779cb843e">&#9670;&#160;</a></span>new_not_less_than_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_not_less_than_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical-comparison 'greater-than or equals' node. </p>
<p>This is the explicit form, which is usually not needed because new "greater-than or equals" nodes can also be created via the overloaded <code>&gt;=</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__not__less__than__node.html">yc_not_less_than_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>&gt;=</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>&gt;=</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a305c26cefe30302d72a1155f41139298" name="a305c26cefe30302d72a1155f41139298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305c26cefe30302d72a1155f41139298">&#9670;&#160;</a></span>new_not_greater_than_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga1c5c1cc63e5d5c7f2b981f715c2608f8">yc_bool_node_ptr</a> yask::yc_node_factory::new_not_greater_than_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga22125cb7af210ef5a3ffad03f544074a">yc_number_node_ptr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a numerical-comparison 'less-than or equals' node. </p>
<p>This is the explicit form, which is usually not needed because new "less-than or equals" nodes can also be created via the overloaded <code>&lt;=</code> operator. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classyask_1_1yc__not__greater__than__node.html">yc_not_greater_than_node</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Expression before <code>&lt;=</code> sign.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Expression after <code>&lt;=</code> sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="yc__node__api_8hpp_source.html">yc_node_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 14 2023 12:49:58 for YASK by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
