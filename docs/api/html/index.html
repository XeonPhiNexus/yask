<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YASK: YASK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kit: a software framework for creating HPC stencil code. Copyright 2014-2023 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">YASK </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction</a><ul><li class="level2"><a href="#yc_intro">Define a Stencil Solution and Generate Kernel Code</a></li>
<li class="level2"><a href="#yk_intro">Create a Stencil Kernel Library and Stencil-based Application</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_yc">YASK Stencil Compiler API</a><ul><li class="level2"><a href="#yc_oview">Compiler Overview</a></li>
<li class="level2"><a href="#yc_usage">Typical Program Flow using the Compiler API</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_yk">YASK Stencil Kernel API</a><ul><li class="level2"><a href="#yk_oview">Kernel Overview</a></li>
<li class="level2"><a href="#yk_usage">Typical Program Flow using the Kernel API</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_tests">Example Tests</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>For an overview of YASK, see the <a href="../../YASK-tutorial.pdf">YASK tutorial</a>.</p>
<p>The typical high-level YASK workflow is as follows:</p><ol type="1">
<li><a class="el" href="index.html#yc_intro">Define a Stencil Solution and Generate Kernel Code</a><ul>
<li>Define a stencil solution using the YASK domain-specific language (DSL).</li>
<li>Use the YASK stencil compiler to generate C++ kernel code from the stencil solution.</li>
</ul>
</li>
<li><a class="el" href="index.html#yk_intro">Create a Stencil Kernel Library and Stencil-based Application</a><ul>
<li>Compile the generated C++ kernel code to create a YASK kernel library.</li>
<li>Create and use a stencil-based application using the kernel library.</li>
</ul>
</li>
<li>Test and deploy your new YASK-enabled application.</li>
</ol>
<p>There are two sets of APIs provided by YASK corresponding to the first two tasks:</p><ol type="1">
<li>The <a class="el" href="index.html#sec_yc">YASK Stencil Compiler API</a> (available in C++ and Python).</li>
<li>The <a class="el" href="index.html#sec_yk">YASK Stencil Kernel API</a> (available in C++ and Python).</li>
</ol>
<p>For each of the tasks, you can either use the YASK-provided application or create your own application built with the corresponding API.</p>
<p>These alternatives may be mixed-or-matched in all combinations. For example, you can use the YASK-provided stencil compiler to generate a YASK kernel library and then use that library via the kernel API to create your own stencil-based Python application.</p>
<p>The following sub-sections describe each of the tasks in the workflow and when the APIs may be used.</p>
<h2><a class="anchor" id="yc_intro"></a>
Define a Stencil Solution and Generate Kernel Code</h2>
<p>A stencil solution consists of the variables containing the problem data and one or more equations that describe how points in the variables are calculated. An equation consists of a point to be calculated that "EQUALS" an expression consisting of other points, constants, mathematical operators, etc.</p><ul>
<li>Example equation: <code>u(t+1, x, y) EQUALS (u(t, x, y) + u(t, x+1, y) + u(t, x, y+1)) / 3</code>.</li>
</ul>
<p>A new stencil solution may be defined in one of the following ways:</p><ol type="1">
<li>Write a stencil in C++ that will be compiled into the standard YASK stencil compiler utility, <code>bin/yask_compiler.exe</code>.<ul>
<li>This approach is typically taken when the programmer or scientist wants to express the equations of the stencil directly, e.g., in a text editor or IDE.</li>
<li>In this case, you must extend the provided base class <a class="el" href="classyask_1_1yc__solution__base.html">yc_solution_base</a> (or <a class="el" href="classyask_1_1yc__solution__with__radius__base.html">yc_solution_with_radius_base</a>). Equations can be typed exactly as shown in the above example (C++ operator overloading is used automatically to construct an internal representation of each equation), and they must be part of the code accessed via the overloaded method <a class="el" href="classyask_1_1yc__solution__base.html#abd34ca7ae7a89fc4a051376a612f494a" title="Define all functionality of this solution.">yc_solution_base::define()</a>. All classes and methods used to create expressions in the YASK compiler API may be used.</li>
<li>To generate the kernel code for the defined stencil, [re]compile and run the YASK stencil compiler. This is done automatically when building a YASK kernel using the YASK <code>Makefile</code>, or you can build it explicity via <code>make compiler</code> and run it from your shell command-prompt.</li>
<li>When you run <code>make</code> to build the kernel library, the generated output from the compiler utility is automatically written to a pre-determined temporary file and compiled into the optimized kernel library.</li>
<li>See example stencils of this type in <code>src/stencils</code>.</li>
</ul>
</li>
<li>Create a custom application that defines stencils.<ul>
<li>This approach is typically taken when a 3rd-party front-end tool will be creating stencils automatically from some other existing format or description.</li>
<li>In this case, you aren't required to use the provided <a class="el" href="classyask_1_1yc__solution__base.html">yc_solution_base</a> class or overload <a class="el" href="classyask_1_1yc__solution__base.html#abd34ca7ae7a89fc4a051376a612f494a" title="Define all functionality of this solution.">yc_solution_base::define()</a>, but equations may be expressed in the same way, because both techniques use the YASK compiler API.</li>
<li>The output from the custom application may be written to any file that is then specified via <code>YK_CODE_FILE=</code><em>filename</em> when running <code>make</code> to build the kernel library.</li>
<li>See <code>src/compiler/tests/yask_compiler_api_test.cpp</code> for an example stencil definition in C++ or <code>src/compiler/tests/yask_compiler_api_test.py</code> for an example stencil definition in Python.</li>
</ul>
</li>
</ol>
<p>In either case, the resulting generated code should written to the C++ stencil-code file to be compiled into the kernel library.</p>
<h2><a class="anchor" id="yk_intro"></a>
Create a Stencil Kernel Library and Stencil-based Application</h2>
<p>Once the stencil-code file is created, it must be compiled into a YASK kernel library.</p><ul>
<li>There will be a separate library created for each stencil solution and target architecture combination.</li>
<li>This is done automatically when building a YASK kernel using the YASK <code>Makefile</code>, e.g., via <code>make -j stencil=iso3dfd arch=knl</code>, which builds the "iso3dfd" stencil for the Intel Xeon Phi processor.</li>
<li>If you generated the stencil-code file via a custom application, you may still create a kernel library using the <code>Makefile</code>; you'll just need to specify the filename via <code>YK_CODE_FILE=</code><em>filename</em> as described above. You'll also still need to specify the target architecture and give a descriptive name to the stencil. Example: <code>make stencil=my-stencil arch=hsw kernel-only YK_CODE_FILE=my_stencil_code.hpp</code>.</li>
</ul>
<p>If <code>make</code> is invoked as in one of the above examples, it will create the kernel library as <code>lib/libyask_kernel.</code><em>stencil.arch</em><code>.so</code>, where <em>stencil</em> and <em>arch</em> match the corresponding variables provided during <code>make</code>. (If you want the file named differently, you can override <em>stencil</em> with <code>YK_STENCIL=</code><em>stencil_name</em> and/or <em>arch</em> with <code>YK_ARCH=</code><em>arch_name</em>.)</p>
<p>To use the kernel library, an executable must be created from it. This may be done in one of the following ways:</p><ol type="1">
<li>The default YASK kernel executable will automatically be created as <code>bin/yask_kernel.</code><em>stencil.arch</em><code>.exe</code> when <code>make</code> is invoked as in the above examples.<ul>
<li>This application may be run via <code>bin/yask.sh</code> to obtain a performance measurement of the kernel.</li>
</ul>
</li>
<li>You can also create your own stencil application using the YASK stencil kernel API.<ul>
<li>This approach would be taken to integrate the kernel into a larger application that would inject real-world initial-state data into the YASK variables and extract the final-state data for analysis or further processing.</li>
<li>See <code>src/kernel/tests/yask_kernel_api_test.cpp</code> for an example kernel usage in C++ or <code>src/kernel/tests/yask_kernel_api_test.py</code> for an example kernel usage in Python.</li>
<li>See <a class="el" href="index.html#sec_yk">YASK Stencil Kernel API</a> for documentation on the kernel API.</li>
</ul>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Anytime you want to change any compile-time properties of the kernel (like vector-folding or prefetching), be sure to run <code>make clean</code> to force the removal of all kernel-specific intermediate code. Otherwise, you will likely see some unexpected errors when building the new kernel.</dd></dl>
<h1><a class="anchor" id="sec_yc"></a>
YASK Stencil Compiler API</h1>
<h2><a class="anchor" id="yc_oview"></a>
Compiler Overview</h2>
<p>This section provides usage information for the YASK stencil compiler API (application-programmer interface).<br  />
The API is available for C++ and for Python via SWIG. Type names are prefixed with 'yc_' to indicate "YASK compiler"; this distinguishes them from the 'yk_'-prefixed types used in the "YASK kernel" API.</p>
<p>The types, classes, and functions are listed in <a class="el" href="group__yc.html">YASK Compiler</a>.</p>
<h2><a class="anchor" id="yc_usage"></a>
Typical Program Flow using the Compiler API</h2>
<ul>
<li>If using the provided YASK stencil compiler utility, <code>bin/yask_compiler.exe</code>:<ul>
<li>Extend the provided base class <a class="el" href="classyask_1_1yc__solution__base.html">yc_solution_base</a> (or <a class="el" href="classyask_1_1yc__solution__with__radius__base.html">yc_solution_with_radius_base</a>).</li>
<li>Create index variables for solution domain dimensions via <a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315" title="Create a domain-index node.">yc_node_factory::new_domain_index()</a> and via <a class="el" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1" title="Create a step-index node.">yc_node_factory::new_step_index()</a> for the step dimension (e.g., "t" for time).</li>
<li>Create an instance of the class to make it visible to the compiler utility.</li>
<li>See the examples in <code>src/stencils</code> showing how to define solutions from these base classes.</li>
</ul>
</li>
<li>If writing your own YASK compiler:<ul>
<li>Create a <a class="el" href="classyask_1_1yc__factory.html" title="Bootstrap factory to create objects needed to define a stencil solution.">yc_factory</a>. This is the "bootstrap" object that will be used to create others.</li>
<li>Create a <a class="el" href="classyask_1_1yc__solution.html" title="Stencil solution.">yc_solution</a> object via <a class="el" href="classyask_1_1yc__factory.html#adce155773c9b0d469263303919681d69" title="Create a stencil solution.">yc_factory::new_solution()</a>.</li>
<li>Create index variablse for solution domain dimensions via <a class="el" href="classyask_1_1yc__node__factory.html#afaa80f553161f4cc4b14b5858f85e315" title="Create a domain-index node.">yc_node_factory::new_domain_index()</a> and via <a class="el" href="classyask_1_1yc__node__factory.html#a77c772e8539b116a9f0adbdf432628a1" title="Create a step-index node.">yc_node_factory::new_step_index()</a> for the step dimension (e.g., "t" for time).</li>
<li>Create one or more <a class="el" href="classyask_1_1yc__var.html">yc_var</a> objects via <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a> as needed by the stencil(s) being implemented. Calls to <a class="el" href="classyask_1_1yc__solution.html#a192b0f12d3943483514e16c82c15a42b" title="Create an n-dimensional variable in the solution.">yc_solution::new_var()</a> specify the name and dimensions of each var. Vars may be read-only (constants) or read-write. Each var will be a part of the solution from which it was created. (Or, you may construct a <a class="el" href="classyask_1_1yc__var__proxy.html">yc_var_proxy</a> object, which is a wrapper around a <a class="el" href="classyask_1_1yc__var.html">yc_var</a> pointer providing some syntactic alternatives that you may prefer.)</li>
</ul>
</li>
<li>Create an equation for each read-write var.<ul>
<li>Think of expressions as abstract syntax trees (ASTs) that describe the mathematical formula that defines each point to be calculated at each new time-step.</li>
<li>Leaf nodes may be floating-point (FP) constants or references to var points.</li>
<li>Constants may created via <a class="el" href="classyask_1_1yc__node__factory.html#ad7ad1075e359ddf1100ec25432b869b3" title="Create a numerical-value expression node.">yc_node_factory::new_number_node()</a>, but this is seldom needed explicitly thanks to operator overloading.</li>
<li>References to points are created via <a class="el" href="classyask_1_1yc__var.html#aad91c7587f75392db28d7a19bb53b423" title="Create a reference to a point in this var.">yc_var::new_var_point()</a>, which specifies the indices relative to the point being evaluated within the problem domain. (If you created <a class="el" href="classyask_1_1yc__var__proxy.html">yc_var_proxy</a> objects, see the alternative syntax shown in the documentation for that class.)</li>
<li>Create operator nodes via normal math operators (<code>+</code>, <code>*</code>, etc.), to build up larger expressions. Some math functions like square-root and cosine are also available.</li>
<li>To complete each equation, use the special <code>EQUALS</code> operator to specify an expression on the right-hand side (RHS) and the point in a variable that is defined to be equal to it on the left-hand side (LHS).</li>
<li>Boolean expressions may be added to equations to specify sub-domains in which they are applied. In this way, boundary layers and conditions may be implemented. It is also possible to add boolean expressions to specify certain time-steps in which equations are valid.</li>
<li>Many examples of using the YASK compiler API to create stencil equations are provided in the <code>src/stencils</code> directory.</li>
</ul>
</li>
<li>Specify the number of bytes in a floating-point element via <a class="el" href="classyask_1_1yc__solution.html#a6ce565febd97f50efae59c37d7d5ef4f" title="Set floating-point precision.">yc_solution::set_element_bytes()</a>. This should be 4 or 8. If you are using the provided YASK compiler utility, this is controlled via the <code>real_bytes=</code><em>4|8</em> <code>make</code> parameter.</li>
<li>Optionally specify the vector-folding and/or vector-clustering via <a class="el" href="classyask_1_1yc__solution.html#a1168b5b8044e39c047d81a5fe5efc06e" title="Set the vectorization length in given dimension.">yc_solution::set_fold_len()</a> and/or <a class="el" href="classyask_1_1yc__solution.html#accddeafe51aa3bc7682e8e70f952afda" title="[Deprecated] Does nothing; will be removed in future versions.">yc_solution::set_cluster_mult()</a>. If you are using the provided YASK compiler utility, these are controlled via the <code>fold=</code><em>fold-spec</em> and <code>cluster=</code><em>cluster-spec</em> <code>make</code> parameters.</li>
<li>Set the target architecture via <a class="el" href="classyask_1_1yc__solution.html#a1c03fc69e306a700de8c5ae3973229c2" title="Set the output target.">yc_solution::set_target()</a>. If you are using the provided YASK compiler utility, this is controlled via the <code>arch=</code><em>arch-name</em> <code>make</code> parameter.</li>
<li>Write the solution code file via <a class="el" href="classyask_1_1yc__solution.html#a9c18b4c2eba024a830d5e43c83df958b" title="Optimize and the current equation(s) and write to given output object.">yc_solution::output_solution()</a>. If you are using the provided YASK compiler utility, this call will be done for you with the proper parameters based on the target architecture.</li>
</ul>
<h1><a class="anchor" id="sec_yk"></a>
YASK Stencil Kernel API</h1>
<p>As discussed earlier, the kernel API is only needed for integrating a YASK kernel into your final application. For evaluating performance, use the provided <code>bin/yask.sh</code> utility, which makes the needed calls to the kernel API for you.</p>
<h2><a class="anchor" id="yk_oview"></a>
Kernel Overview</h2>
<p>This section provides usage information for the YASK stencil kernel API (application-programmer interface).<br  />
The API is available for C++ and for Python via SWIG. Type names are prefixed with 'yk_' to indicate "YASK kernel"; this distinguishes them from the 'yc_'-prefixed types used in the "YASK compiler" API.</p>
<p>The types, classes, and functions are listed in <a class="el" href="group__yk.html">YASK Kernel</a>.</p>
<h2><a class="anchor" id="yk_usage"></a>
Typical Program Flow using the Kernel API</h2>
<ul>
<li>Create a <a class="el" href="classyask_1_1yk__factory.html">yk_factory</a>. This is the "bootstrap" object that will be used to create others.</li>
<li>Create a <a class="el" href="classyask_1_1yk__env.html">yk_env</a> object via <a class="el" href="classyask_1_1yk__factory.html#afccc05b0095d99f89b7164b603b53d00" title="Create an object to hold environment information.">yk_factory::new_env()</a>. This initializes MPI if you have enabled it.</li>
<li>Create a <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> object via <a class="el" href="classyask_1_1yk__factory.html#a755b1bfc0dd9bfddfe80d924a188b350" title="Create a stencil solution.">yk_factory::new_solution()</a>. A pointer to the environment object is provided. This structure allows you to initialize MPI early in the program. The solution contains the vars and equations defined by the stencil compiler process.</li>
<li>Use the <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> methods to configure options like the size of the problem domain.</li>
<li>Set up internal data structures via <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>. This adjusts any settings as needed, determines each rank's position in the problem if MPI is enabled, and allocates data for the vars. Be sure to modify any settings before calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application.">yk_solution::prepare_solution()</a>.</li>
<li>Access the solution vars via <a class="el" href="classyask_1_1yk__solution.html#a068d8968ac1846a9ea5af7ca2defaf79" title="Get the specified var.">yk_solution::get_var()</a>. Various properties of each var may be retrieved or set. In particular, you should initialize the data in each var via <a class="el" href="classyask_1_1yk__var.html#a0cbfa0153ac69dfadf0e655246ddeac2" title="Initialize all var elements to the same value.">yk_var::set_all_elements_same()</a> and <a class="el" href="classyask_1_1yk__var.html#ac509cdab014c58033c15b5c92f4bb7d6" title="Set the value of one element in this var.">yk_var::set_element()</a>.</li>
<li>Apply the stencil(s) to the vars via <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps.">yk_solution::run_solution()</a>. There are versions for advancing one or more steps.</li>
<li>Retrieve the final results via <a class="el" href="classyask_1_1yk__var.html#aed2d676221d5b99be7b8b8bc2cd37af2" title="Read the value of one element in this var.">yk_var::get_element()</a>.</li>
</ul>
<h1><a class="anchor" id="sec_tests"></a>
Example Tests</h1>
<p>The following examples illustrate possible combinations of compilers and kernels and show how to invoke a set of tests for each combination.</p><ul>
<li>You can add <code>stencil=</code>_stencil-name_ to use a specific stencil for testing.</li>
<li>You can add <code>arch=</code>_arch-name_ to target one of the architectures listed in the <code>Makefile</code> if desired.</li>
<li>Run <code>make clean</code> before all of the example commands to ensure consistent builds.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stencil Compiler   </th><th class="markdownTableHeadNone">Stencil Application   </th><th class="markdownTableHeadNone">Test Command    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">YASK-provided   </td><td class="markdownTableBodyNone">YASK-provided   </td><td class="markdownTableBodyNone"><code>make -j yc-and-yk-test</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">YASK-provided   </td><td class="markdownTableBodyNone">C++ test example   </td><td class="markdownTableBodyNone"><code>make -j yc-and-cxx-yk-api-test</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">YASK-provided   </td><td class="markdownTableBodyNone">Python test example   </td><td class="markdownTableBodyNone"><code>make -j yc-and-py-yk-api-test</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ test example   </td><td class="markdownTableBodyNone">YASK-provided   </td><td class="markdownTableBodyNone"><code>make -j cxx-yc-api-and-yk-test</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">C++ test example   </td><td class="markdownTableBodyNone">C++ test example   </td><td class="markdownTableBodyNone"><code>make -j cxx-yc-api-and-cxx-yk-api-test</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ test example   </td><td class="markdownTableBodyNone">Python test example   </td><td class="markdownTableBodyNone"><code>make -j cxx-yc-api-and-py-yk-api-test</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Python test example   </td><td class="markdownTableBodyNone">YASK-provided   </td><td class="markdownTableBodyNone"><code>make -j py-yc-api-and-yk-test</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Python test example   </td><td class="markdownTableBodyNone">C++ test example   </td><td class="markdownTableBodyNone"><code>make -j py-yc-api-and-cxx-yk-api-test</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Python test example   </td><td class="markdownTableBodyNone">Python test example   </td><td class="markdownTableBodyNone"><code>make -j py-yc-api-and-py-yk-api-test</code>   </td></tr>
</table>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 14 2023 12:49:58 for YASK by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
